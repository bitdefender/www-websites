{"version":3,"file":"request.js","sources":["../../../../../../../../node_modules/@sentry/browser/build/npm/esm/tracing/request.js"],"sourcesContent":["import { addFetchEndInstrumentationHandler, addFetchInstrumentationHandler, instrumentFetchRequest, parseUrl, getLocationHref, stringMatchesSomePattern, spanToJSON, hasSpansEnabled, setHttpStatus, stripUrlQueryAndFragment, getActiveSpan, startInactiveSpan, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SentryNonRecordingSpan, getClient, browserPerformanceTimeOrigin, getTraceData } from '@sentry/core';\nimport { addXhrInstrumentationHandler, addPerformanceInstrumentationHandler, SENTRY_XHR_DATA_KEY, extractNetworkProtocol } from '@sentry-internal/browser-utils';\nimport { WINDOW } from '../helpers.js';\n\n/** Options for Request Instrumentation */\n\nconst responseToSpanId = new WeakMap();\nconst spanIdToEndTimestamp = new Map();\n\nconst defaultRequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n  trackFetchStreamPerformance: false,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nfunction instrumentOutgoingRequests(client, _options) {\n  const {\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    tracePropagationTargets,\n    onRequestSpanStart,\n  } = {\n    ...defaultRequestInstrumentationOptions,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_) => true;\n\n  const shouldAttachHeadersWithTargets = (url) => shouldAttachHeaders(url, tracePropagationTargets);\n\n  const spans = {};\n\n  if (traceFetch) {\n    // Keeping track of http requests, whose body payloads resolved later than the initial resolved request\n    // e.g. streaming using server sent events (SSE)\n    client.addEventProcessor(event => {\n      if (event.type === 'transaction' && event.spans) {\n        event.spans.forEach(span => {\n          if (span.op === 'http.client') {\n            const updatedTimestamp = spanIdToEndTimestamp.get(span.span_id);\n            if (updatedTimestamp) {\n              span.timestamp = updatedTimestamp / 1000;\n              spanIdToEndTimestamp.delete(span.span_id);\n            }\n          }\n        });\n      }\n      return event;\n    });\n\n    if (trackFetchStreamPerformance) {\n      addFetchEndInstrumentationHandler(handlerData => {\n        if (handlerData.response) {\n          const span = responseToSpanId.get(handlerData.response);\n          if (span && handlerData.endTimestamp) {\n            spanIdToEndTimestamp.set(span, handlerData.endTimestamp);\n          }\n        }\n      });\n    }\n\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n\n      if (handlerData.response && handlerData.fetchData.__span) {\n        responseToSpanId.set(handlerData.response, handlerData.fetchData.__span);\n      }\n\n      // We cannot use `window.location` in the generic fetch instrumentation,\n      // but we need it for reliable `server.address` attribute.\n      // so we extend this in here\n      if (createdSpan) {\n        const fullUrl = getFullURL(handlerData.fetchData.url);\n        const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n        createdSpan.setAttributes({\n          'http.url': fullUrl,\n          'server.address': host,\n        });\n\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n\n        onRequestSpanStart?.(createdSpan, { headers: handlerData.headers });\n      }\n    });\n  }\n\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (createdSpan) {\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n\n        let headers;\n        try {\n          headers = new Headers(handlerData.xhr.__sentry_xhr_v3__?.request_headers);\n        } catch {\n          // noop\n        }\n        onRequestSpanStart?.(createdSpan, { headers });\n      }\n    });\n  }\n}\n\nfunction isPerformanceResourceTiming(entry) {\n  return (\n    entry.entryType === 'resource' &&\n    'initiatorType' in entry &&\n    typeof (entry ).nextHopProtocol === 'string' &&\n    (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest')\n  );\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span) {\n  const { url } = spanToJSON(span).data;\n\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n\n  const cleanup = addPerformanceInstrumentationHandler('resource', ({ entries }) => {\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanData = resourceTimingEntryToSpanData(entry);\n        spanData.forEach(data => span.setAttribute(...data));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\n\nfunction getAbsoluteTime(time = 0) {\n  return ((browserPerformanceTimeOrigin() || performance.timeOrigin) + time) / 1000;\n}\n\nfunction resourceTimingEntryToSpanData(resourceTiming) {\n  const { name, version } = extractNetworkProtocol(resourceTiming.nextHopProtocol);\n\n  const timingSpanData = [];\n\n  timingSpanData.push(['network.protocol.version', version], ['network.protocol.name', name]);\n\n  if (!browserPerformanceTimeOrigin()) {\n    return timingSpanData;\n  }\n  return [\n    ...timingSpanData,\n    ['http.request.redirect_start', getAbsoluteTime(resourceTiming.redirectStart)],\n    ['http.request.fetch_start', getAbsoluteTime(resourceTiming.fetchStart)],\n    ['http.request.domain_lookup_start', getAbsoluteTime(resourceTiming.domainLookupStart)],\n    ['http.request.domain_lookup_end', getAbsoluteTime(resourceTiming.domainLookupEnd)],\n    ['http.request.connect_start', getAbsoluteTime(resourceTiming.connectStart)],\n    ['http.request.secure_connection_start', getAbsoluteTime(resourceTiming.secureConnectionStart)],\n    ['http.request.connection_end', getAbsoluteTime(resourceTiming.connectEnd)],\n    ['http.request.request_start', getAbsoluteTime(resourceTiming.requestStart)],\n    ['http.request.response_start', getAbsoluteTime(resourceTiming.responseStart)],\n    ['http.request.response_end', getAbsoluteTime(resourceTiming.responseEnd)],\n  ];\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * We only export this function for testing purposes.\n */\nfunction shouldAttachHeaders(\n  targetUrl,\n  tracePropagationTargets,\n) {\n  // window.location.href not being defined is an edge case in the browser but we need to handle it.\n  // Potentially dangerous situations where it may not be defined: Browser Extensions, Web Workers, patching of the location obj\n  const href = getLocationHref();\n\n  if (!href) {\n    // If there is no window.location.origin, we default to only attaching tracing headers to relative requests, i.e. ones that start with `/`\n    // BIG DISCLAIMER: Users can call URLs with a double slash (fetch(\"//example.com/api\")), this is a shorthand for \"send to the same protocol\",\n    // so we need a to exclude those requests, because they might be cross origin.\n    const isRelativeSameOriginRequest = !!targetUrl.match(/^\\/(?!\\/)/);\n    if (!tracePropagationTargets) {\n      return isRelativeSameOriginRequest;\n    } else {\n      return stringMatchesSomePattern(targetUrl, tracePropagationTargets);\n    }\n  } else {\n    let resolvedUrl;\n    let currentOrigin;\n\n    // URL parsing may fail, we default to not attaching trace headers in that case.\n    try {\n      resolvedUrl = new URL(targetUrl, href);\n      currentOrigin = new URL(href).origin;\n    } catch (e) {\n      return false;\n    }\n\n    const isSameOriginRequest = resolvedUrl.origin === currentOrigin;\n    if (!tracePropagationTargets) {\n      return isSameOriginRequest;\n    } else {\n      return (\n        stringMatchesSomePattern(resolvedUrl.toString(), tracePropagationTargets) ||\n        (isSameOriginRequest && stringMatchesSomePattern(resolvedUrl.pathname, tracePropagationTargets))\n      );\n    }\n  }\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction xhrCallback(\n  handlerData,\n  shouldCreateSpan,\n  shouldAttachHeaders,\n  spans,\n) {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr?.[SENTRY_XHR_DATA_KEY];\n\n  if (!xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n\n  const { url, method } = sentryXhrData;\n\n  const shouldCreateSpanResult = hasSpansEnabled() && shouldCreateSpan(url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const fullUrl = getFullURL(url);\n  const parsedUrl = fullUrl ? parseUrl(fullUrl) : parseUrl(url);\n\n  const urlForSpanName = stripUrlQueryAndFragment(url);\n\n  const hasParent = !!getActiveSpan();\n\n  const span =\n    shouldCreateSpanResult && hasParent\n      ? startInactiveSpan({\n          name: `${method} ${urlForSpanName}`,\n          attributes: {\n            url,\n            type: 'xhr',\n            'http.method': method,\n            'http.url': fullUrl,\n            'server.address': parsedUrl?.host,\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n            ...(parsedUrl?.search && { 'http.query': parsedUrl?.search }),\n            ...(parsedUrl?.hash && { 'http.fragment': parsedUrl?.hash }),\n          },\n        })\n      : new SentryNonRecordingSpan();\n\n  xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n  spans[xhr.__sentry_xhr_span_id__] = span;\n\n  if (shouldAttachHeaders(url)) {\n    addTracingHeadersToXhrRequest(\n      xhr,\n      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n      // we do not want to use the span as base for the trace headers,\n      // which means that the headers will be generated from the scope and the sampling decision is deferred\n      hasSpansEnabled() && hasParent ? span : undefined,\n    );\n  }\n\n  const client = getClient();\n  if (client) {\n    client.emit('beforeOutgoingRequestSpan', span, handlerData );\n  }\n\n  return span;\n}\n\nfunction addTracingHeadersToXhrRequest(xhr, span) {\n  const { 'sentry-trace': sentryTrace, baggage } = getTraceData({ span });\n\n  if (sentryTrace) {\n    setHeaderOnXhr(xhr, sentryTrace, baggage);\n  }\n}\n\nfunction setHeaderOnXhr(\n  xhr,\n  sentryTraceHeader,\n  sentryBaggageHeader,\n) {\n  const originalHeaders = xhr.__sentry_xhr_v3__?.request_headers;\n\n  if (originalHeaders?.['sentry-trace']) {\n    // bail if a sentry-trace header is already set\n    return;\n  }\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // only add our headers if\n      // - no pre-existing baggage header exists\n      // - or it is set and doesn't yet contain sentry values\n      const originalBaggageHeader = originalHeaders?.['baggage'];\n      if (!originalBaggageHeader || !baggageHeaderHasSentryValues(originalBaggageHeader)) {\n        // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n        // We can therefore simply set a baggage header without checking what was there before\n        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        xhr.setRequestHeader('baggage', sentryBaggageHeader);\n      }\n    }\n  } catch (_) {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\n\nfunction baggageHeaderHasSentryValues(baggageHeader) {\n  return baggageHeader.split(',').some(value => value.trim().startsWith('sentry-'));\n}\n\nfunction getFullURL(url) {\n  try {\n    // By adding a base URL to new URL(), this will also work for relative urls\n    // If `url` is a full URL, the base URL is ignored anyhow\n    const parsed = new URL(url, WINDOW.location.origin);\n    return parsed.href;\n  } catch {\n    return undefined;\n  }\n}\n\nexport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests, shouldAttachHeaders, xhrCallback };\n//# sourceMappingURL=request.js.map\n"],"names":["responseToSpanId","spanIdToEndTimestamp","defaultRequestInstrumentationOptions","instrumentOutgoingRequests","client","_options","traceFetch","traceXHR","trackFetchStreamPerformance","shouldCreateSpanForRequest","enableHTTPTimings","tracePropagationTargets","onRequestSpanStart","shouldCreateSpan","_","shouldAttachHeadersWithTargets","url","shouldAttachHeaders","spans","event","span","updatedTimestamp","addFetchEndInstrumentationHandler","handlerData","addFetchInstrumentationHandler","createdSpan","instrumentFetchRequest","fullUrl","getFullURL","host","parseUrl","addHTTPTimings","addXhrInstrumentationHandler","xhrCallback","headers","isPerformanceResourceTiming","entry","spanToJSON","cleanup","addPerformanceInstrumentationHandler","entries","resourceTimingEntryToSpanData","data","getAbsoluteTime","time","browserPerformanceTimeOrigin","resourceTiming","name","version","extractNetworkProtocol","timingSpanData","targetUrl","href","getLocationHref","resolvedUrl","currentOrigin","isSameOriginRequest","stringMatchesSomePattern","isRelativeSameOriginRequest","xhr","sentryXhrData","SENTRY_XHR_DATA_KEY","method","shouldCreateSpanResult","hasSpansEnabled","spanId","setHttpStatus","parsedUrl","urlForSpanName","stripUrlQueryAndFragment","hasParent","getActiveSpan","startInactiveSpan","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","SentryNonRecordingSpan","addTracingHeadersToXhrRequest","getClient","sentryTrace","baggage","getTraceData","setHeaderOnXhr","sentryTraceHeader","sentryBaggageHeader","originalHeaders","originalBaggageHeader","baggageHeaderHasSentryValues","baggageHeader","value","WINDOW"],"mappings":"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","x_google_ignoreList":[0]}