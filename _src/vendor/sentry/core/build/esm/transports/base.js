import{DEBUG_BUILD as s}from"../debug-build.js";import{forEachEnvelopeItem as c,createEnvelope as h,serializeEnvelope as L,envelopeItemTypeToDataCategory as l}from"../utils-hoist/envelope.js";import{logger as a}from"../utils-hoist/logger.js";import{makePromiseBuffer as T,SENTRY_BUFFER_FULL_ERROR as g}from"../utils-hoist/promisebuffer.js";import{updateRateLimits as S,isRateLimited as w}from"../utils-hoist/ratelimit.js";import{resolvedSyncPromise as p}from"../utils-hoist/syncpromise.js";const y=64;function I(o,E,d=T(o.bufferSize||y)){let n={};const v=t=>d.drain(t);function R(t){const i=[];if(c(t,(e,m)=>{const r=l(m);w(n,r)?o.recordDroppedEvent("ratelimit_backoff",r):i.push(e)}),i.length===0)return p({});const u=h(t[0],i),f=e=>{c(u,(m,r)=>{o.recordDroppedEvent(e,l(r))})},_=()=>E({body:L(u)}).then(e=>(e.statusCode!==void 0&&(e.statusCode<200||e.statusCode>=300)&&s&&a.warn(`Sentry responded with status code ${e.statusCode} to sent event.`),n=S(n,e),e),e=>{throw f("network_error"),s&&a.error("Encountered error running transport request:",e),e});return d.add(_).then(e=>e,e=>{if(e===g)return s&&a.error("Skipped sending event because buffer is full."),f("queue_overflow"),p({});throw e})}return{send:R,flush:v}}export{y as DEFAULT_TRANSPORT_BUFFER_SIZE,I as createTransport};
//# sourceMappingURL=base.js.map
