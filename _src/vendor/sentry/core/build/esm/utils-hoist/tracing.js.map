{"version":3,"file":"tracing.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/utils-hoist/tracing.js"],"sourcesContent":["import { parseSampleRate } from '../utils/parseSampleRate.js';\nimport { baggageHeaderToDynamicSamplingContext } from './baggage.js';\nimport { generateTraceId, generateSpanId } from './propagationContext.js';\n\n// eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor -- RegExp is used for readability here\nconst TRACEPARENT_REGEXP = new RegExp(\n  '^[ \\\\t]*' + // whitespace\n    '([0-9a-f]{32})?' + // trace_id\n    '-?([0-9a-f]{16})?' + // span_id\n    '-?([01])?' + // sampled\n    '[ \\\\t]*$', // whitespace\n);\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nfunction extractTraceparentData(traceparent) {\n  if (!traceparent) {\n    return undefined;\n  }\n\n  const matches = traceparent.match(TRACEPARENT_REGEXP);\n  if (!matches) {\n    return undefined;\n  }\n\n  let parentSampled;\n  if (matches[3] === '1') {\n    parentSampled = true;\n  } else if (matches[3] === '0') {\n    parentSampled = false;\n  }\n\n  return {\n    traceId: matches[1],\n    parentSampled,\n    parentSpanId: matches[2],\n  };\n}\n\n/**\n * Create a propagation context from incoming headers or\n * creates a minimal new one if the headers are undefined.\n */\nfunction propagationContextFromHeaders(\n  sentryTrace,\n  baggage,\n) {\n  const traceparentData = extractTraceparentData(sentryTrace);\n  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);\n\n  if (!traceparentData?.traceId) {\n    return {\n      traceId: generateTraceId(),\n      sampleRand: Math.random(),\n    };\n  }\n\n  const sampleRand = getSampleRandFromTraceparentAndDsc(traceparentData, dynamicSamplingContext);\n\n  // The sample_rand on the DSC needs to be generated based on traceparent + baggage.\n  if (dynamicSamplingContext) {\n    dynamicSamplingContext.sample_rand = sampleRand.toString();\n  }\n\n  const { traceId, parentSpanId, parentSampled } = traceparentData;\n\n  return {\n    traceId,\n    parentSpanId,\n    sampled: parentSampled,\n    dsc: dynamicSamplingContext || {}, // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n    sampleRand,\n  };\n}\n\n/**\n * Create sentry-trace header from span context values.\n */\nfunction generateSentryTraceHeader(\n  traceId = generateTraceId(),\n  spanId = generateSpanId(),\n  sampled,\n) {\n  let sampledString = '';\n  if (sampled !== undefined) {\n    sampledString = sampled ? '-1' : '-0';\n  }\n  return `${traceId}-${spanId}${sampledString}`;\n}\n\n/**\n * Given any combination of an incoming trace, generate a sample rand based on its defined semantics.\n *\n * Read more: https://develop.sentry.dev/sdk/telemetry/traces/#propagated-random-value\n */\nfunction getSampleRandFromTraceparentAndDsc(\n  traceparentData,\n  dsc,\n) {\n  // When there is an incoming sample rand use it.\n  const parsedSampleRand = parseSampleRate(dsc?.sample_rand);\n  if (parsedSampleRand !== undefined) {\n    return parsedSampleRand;\n  }\n\n  // Otherwise, if there is an incoming sampling decision + sample rate, generate a sample rand that would lead to the same sampling decision.\n  const parsedSampleRate = parseSampleRate(dsc?.sample_rate);\n  if (parsedSampleRate && traceparentData?.parentSampled !== undefined) {\n    return traceparentData.parentSampled\n      ? // Returns a sample rand with positive sampling decision [0, sampleRate)\n        Math.random() * parsedSampleRate\n      : // Returns a sample rand with negative sampling decision [sampleRate, 1)\n        parsedSampleRate + Math.random() * (1 - parsedSampleRate);\n  } else {\n    // If nothing applies, return a random sample rand.\n    return Math.random();\n  }\n}\n\nexport { TRACEPARENT_REGEXP, extractTraceparentData, generateSentryTraceHeader, propagationContextFromHeaders };\n//# sourceMappingURL=tracing.js.map\n"],"names":["TRACEPARENT_REGEXP","extractTraceparentData","traceparent","matches","parentSampled","propagationContextFromHeaders","sentryTrace","baggage","traceparentData","dynamicSamplingContext","baggageHeaderToDynamicSamplingContext","generateTraceId","sampleRand","getSampleRandFromTraceparentAndDsc","traceId","parentSpanId","generateSentryTraceHeader","spanId","generateSpanId","sampled","sampledString","dsc","parsedSampleRand","parseSampleRate","parsedSampleRate"],"mappings":"iNAKK,MAACA,EAAqB,IAAI,OAC7B,2DAKF,EASA,SAASC,EAAuBC,EAAa,CAC3C,GAAI,CAACA,EACH,OAGF,MAAMC,EAAUD,EAAY,MAAMF,CAAkB,EACpD,GAAI,CAACG,EACH,OAGF,IAAIC,EACJ,OAAID,EAAQ,CAAC,IAAM,IACjBC,EAAgB,GACPD,EAAQ,CAAC,IAAM,MACxBC,EAAgB,IAGX,CACL,QAASD,EAAQ,CAAC,EAClB,cAAAC,EACA,aAAcD,EAAQ,CAAC,CACxB,CACH,CAMA,SAASE,EACPC,EACAC,EACA,CACA,MAAMC,EAAkBP,EAAuBK,CAAW,EACpDG,EAAyBC,EAAsCH,CAAO,EAE5E,GAAI,CAACC,GAAiB,QACpB,MAAO,CACL,QAASG,EAAiB,EAC1B,WAAY,KAAK,OAAQ,CAC1B,EAGH,MAAMC,EAAaC,EAAmCL,EAAiBC,CAAsB,EAGzFA,IACFA,EAAuB,YAAcG,EAAW,SAAU,GAG5D,KAAM,CAAE,QAAAE,EAAS,aAAAC,EAAc,cAAAX,CAAe,EAAGI,EAEjD,MAAO,CACL,QAAAM,EACA,aAAAC,EACA,QAASX,EACT,IAAKK,GAA0B,CAAE,EACjC,WAAAG,CACD,CACH,CAKA,SAASI,EACPF,EAAUH,EAAiB,EAC3BM,EAASC,EAAgB,EACzBC,EACA,CACA,IAAIC,EAAgB,GACpB,OAAID,IAAY,SACdC,EAAgBD,EAAU,KAAO,MAE5B,GAAGL,CAAO,IAAIG,CAAM,GAAGG,CAAa,EAC7C,CAOA,SAASP,EACPL,EACAa,EACA,CAEA,MAAMC,EAAmBC,EAAgBF,GAAK,WAAW,EACzD,GAAIC,IAAqB,OACvB,OAAOA,EAIT,MAAME,EAAmBD,EAAgBF,GAAK,WAAW,EACzD,OAAIG,GAAoBhB,GAAiB,gBAAkB,OAClDA,EAAgB,cAEnB,KAAK,OAAM,EAAKgB,EAEhBA,EAAmB,KAAK,UAAY,EAAIA,GAGrC,KAAK,OAAQ,CAExB","x_google_ignoreList":[0]}