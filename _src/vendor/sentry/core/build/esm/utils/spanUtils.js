import{getAsyncContextStrategy as l}from"../asyncContext/index.js";import{getMainCarrier as A}from"../carrier.js";import{getCurrentScope as C}from"../currentScopes.js";import{SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN as x,SEMANTIC_ATTRIBUTE_SENTRY_OP as y}from"../semanticAttributes.js";import{SPAN_STATUS_UNSET as N,SPAN_STATUS_OK as E}from"../tracing/spanstatus.js";import{getCapturedScopesOnSpan as R}from"../tracing/utils.js";import{consoleSandbox as O}from"../utils-hoist/logger.js";import{addNonEnumerableProperty as S}from"../utils-hoist/object.js";import{generateSpanId as h}from"../utils-hoist/propagationContext.js";import{timestampInSeconds as D}from"../utils-hoist/time.js";import{generateSentryTraceHeader as F}from"../utils-hoist/tracing.js";import{_getSpanForScope as P}from"./spanOnScope.js";const z=0,_=1;let f=!1;function Q(n){const{spanId:t,traceId:r}=n.spanContext(),{data:e,op:o,parent_span_id:a,status:s,origin:c,links:p}=T(n);return{parent_span_id:a,span_id:t,trace_id:r,data:e,op:o,status:s,origin:c,links:p}}function V(n){const{spanId:t,traceId:r,isRemote:e}=n.spanContext(),o=e?t:T(n).parent_span_id,a=R(n).scope,s=e?a?.getPropagationContext().propagationSpanId||h():t;return{parent_span_id:o,span_id:s,trace_id:r}}function X(n){const{traceId:t,spanId:r}=n.spanContext(),e=g(n);return F(t,r,e)}function v(n){if(n&&n.length>0)return n.map(({context:{spanId:t,traceId:r,traceFlags:e,...o},attributes:a})=>({span_id:t,trace_id:r,sampled:e===_,attributes:a,...o}))}function u(n){return typeof n=="number"?m(n):Array.isArray(n)?n[0]+n[1]/1e9:n instanceof Date?m(n.getTime()):D()}function m(n){return n>9999999999?n/1e3:n}function T(n){if(L(n))return n.getSpanJSON();const{spanId:t,traceId:r}=n.spanContext();if(w(n)){const{attributes:e,startTime:o,name:a,endTime:s,status:c,links:p}=n,I="parentSpanId"in n?n.parentSpanId:"parentSpanContext"in n?n.parentSpanContext?.spanId:void 0;return{span_id:t,trace_id:r,data:e,description:a,parent_span_id:I,start_timestamp:u(o),timestamp:u(s)||void 0,status:M(c),op:e[y],origin:e[x],links:v(p)}}return{span_id:t,trace_id:r,start_timestamp:0,data:{}}}function w(n){const t=n;return!!t.attributes&&!!t.startTime&&!!t.name&&!!t.endTime&&!!t.status}function L(n){return typeof n.getSpanJSON=="function"}function g(n){const{traceFlags:t}=n.spanContext();return t===_}function M(n){if(!(!n||n.code===N))return n.code===E?"ok":n.message||"unknown_error"}const i="_sentryChildSpans",d="_sentryRootSpan";function Z(n,t){const r=n[d]||n;S(t,d,r),n[i]?n[i].add(t):S(n,i,new Set([t]))}function $(n,t){n[i]&&n[i].delete(t)}function nn(n){const t=new Set;function r(e){if(!t.has(e)&&g(e)){t.add(e);const o=e[i]?Array.from(e[i]):[];for(const a of o)r(a)}}return r(n),Array.from(t)}function tn(n){return n[d]||n}function en(){const n=A(),t=l(n);return t.getActiveSpan?t.getActiveSpan():P(C())}function rn(){f||(O(()=>{console.warn("[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly.")}),f=!0)}export{z as TRACE_FLAG_NONE,_ as TRACE_FLAG_SAMPLED,Z as addChildSpanToSpan,v as convertSpanLinksForEnvelope,en as getActiveSpan,tn as getRootSpan,nn as getSpanDescendants,M as getStatusMessage,$ as removeChildSpanFromSpan,rn as showSpanDropWarning,g as spanIsSampled,u as spanTimeInputToSeconds,T as spanToJSON,V as spanToTraceContext,X as spanToTraceHeader,Q as spanToTransactionTraceContext};
//# sourceMappingURL=spanUtils.js.map
