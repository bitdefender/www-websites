{"version":3,"file":"spanUtils.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/utils/spanUtils.js"],"sourcesContent":["import { getAsyncContextStrategy } from '../asyncContext/index.js';\nimport { getMainCarrier } from '../carrier.js';\nimport { getCurrentScope } from '../currentScopes.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '../semanticAttributes.js';\nimport { SPAN_STATUS_UNSET, SPAN_STATUS_OK } from '../tracing/spanstatus.js';\nimport { getCapturedScopesOnSpan } from '../tracing/utils.js';\nimport { consoleSandbox } from '../utils-hoist/logger.js';\nimport { addNonEnumerableProperty } from '../utils-hoist/object.js';\nimport { generateSpanId } from '../utils-hoist/propagationContext.js';\nimport { timestampInSeconds } from '../utils-hoist/time.js';\nimport { generateSentryTraceHeader } from '../utils-hoist/tracing.js';\nimport { _getSpanForScope } from './spanOnScope.js';\n\n// These are aligned with OpenTelemetry trace flags\nconst TRACE_FLAG_NONE = 0x0;\nconst TRACE_FLAG_SAMPLED = 0x1;\n\nlet hasShownSpanDropWarning = false;\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in an event.\n * By default, this will only include trace_id, span_id & parent_span_id.\n * If `includeAllData` is true, it will also include data, op, status & origin.\n */\nfunction spanToTransactionTraceContext(span) {\n  const { spanId: span_id, traceId: trace_id } = span.spanContext();\n  const { data, op, parent_span_id, status, origin, links } = spanToJSON(span);\n\n  return {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data,\n    op,\n    status,\n    origin,\n    links,\n  };\n}\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in a non-transaction event.\n */\nfunction spanToTraceContext(span) {\n  const { spanId, traceId: trace_id, isRemote } = span.spanContext();\n\n  // If the span is remote, we use a random/virtual span as span_id to the trace context,\n  // and the remote span as parent_span_id\n  const parent_span_id = isRemote ? spanId : spanToJSON(span).parent_span_id;\n  const scope = getCapturedScopesOnSpan(span).scope;\n\n  const span_id = isRemote ? scope?.getPropagationContext().propagationSpanId || generateSpanId() : spanId;\n\n  return {\n    parent_span_id,\n    span_id,\n    trace_id,\n  };\n}\n\n/**\n * Convert a Span to a Sentry trace header.\n */\nfunction spanToTraceHeader(span) {\n  const { traceId, spanId } = span.spanContext();\n  const sampled = spanIsSampled(span);\n  return generateSentryTraceHeader(traceId, spanId, sampled);\n}\n\n/**\n *  Converts the span links array to a flattened version to be sent within an envelope.\n *\n *  If the links array is empty, it returns `undefined` so the empty value can be dropped before it's sent.\n */\nfunction convertSpanLinksForEnvelope(links) {\n  if (links && links.length > 0) {\n    return links.map(({ context: { spanId, traceId, traceFlags, ...restContext }, attributes }) => ({\n      span_id: spanId,\n      trace_id: traceId,\n      sampled: traceFlags === TRACE_FLAG_SAMPLED,\n      attributes,\n      ...restContext,\n    }));\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Convert a span time input into a timestamp in seconds.\n */\nfunction spanTimeInputToSeconds(input) {\n  if (typeof input === 'number') {\n    return ensureTimestampInSeconds(input);\n  }\n\n  if (Array.isArray(input)) {\n    // See {@link HrTime} for the array-based time format\n    return input[0] + input[1] / 1e9;\n  }\n\n  if (input instanceof Date) {\n    return ensureTimestampInSeconds(input.getTime());\n  }\n\n  return timestampInSeconds();\n}\n\n/**\n * Converts a timestamp to second, if it was in milliseconds, or keeps it as second.\n */\nfunction ensureTimestampInSeconds(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Convert a span to a JSON representation.\n */\n// Note: Because of this, we currently have a circular type dependency (which we opted out of in package.json).\n// This is not avoidable as we need `spanToJSON` in `spanUtils.ts`, which in turn is needed by `span.ts` for backwards compatibility.\n// And `spanToJSON` needs the Span class from `span.ts` to check here.\nfunction spanToJSON(span) {\n  if (spanIsSentrySpan(span)) {\n    return span.getSpanJSON();\n  }\n\n  const { spanId: span_id, traceId: trace_id } = span.spanContext();\n\n  // Handle a span from @opentelemetry/sdk-base-trace's `Span` class\n  if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {\n    const { attributes, startTime, name, endTime, status, links } = span;\n\n    // In preparation for the next major of OpenTelemetry, we want to support\n    // looking up the parent span id according to the new API\n    // In OTel v1, the parent span id is accessed as `parentSpanId`\n    // In OTel v2, the parent span id is accessed as `spanId` on the `parentSpanContext`\n    const parentSpanId =\n      'parentSpanId' in span\n        ? span.parentSpanId\n        : 'parentSpanContext' in span\n          ? (span.parentSpanContext )?.spanId\n          : undefined;\n\n    return {\n      span_id,\n      trace_id,\n      data: attributes,\n      description: name,\n      parent_span_id: parentSpanId,\n      start_timestamp: spanTimeInputToSeconds(startTime),\n      // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n      timestamp: spanTimeInputToSeconds(endTime) || undefined,\n      status: getStatusMessage(status),\n      op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],\n      origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ,\n      links: convertSpanLinksForEnvelope(links),\n    };\n  }\n\n  // Finally, at least we have `spanContext()`....\n  // This should not actually happen in reality, but we need to handle it for type safety.\n  return {\n    span_id,\n    trace_id,\n    start_timestamp: 0,\n    data: {},\n  };\n}\n\nfunction spanIsOpenTelemetrySdkTraceBaseSpan(span) {\n  const castSpan = span ;\n  return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;\n}\n\n/** Exported only for tests. */\n\n/**\n * Sadly, due to circular dependency checks we cannot actually import the Span class here and check for instanceof.\n * :( So instead we approximate this by checking if it has the `getSpanJSON` method.\n */\nfunction spanIsSentrySpan(span) {\n  return typeof (span ).getSpanJSON === 'function';\n}\n\n/**\n * Returns true if a span is sampled.\n * In most cases, you should just use `span.isRecording()` instead.\n * However, this has a slightly different semantic, as it also returns false if the span is finished.\n * So in the case where this distinction is important, use this method.\n */\nfunction spanIsSampled(span) {\n  // We align our trace flags with the ones OpenTelemetry use\n  // So we also check for sampled the same way they do.\n  const { traceFlags } = span.spanContext();\n  return traceFlags === TRACE_FLAG_SAMPLED;\n}\n\n/** Get the status message to use for a JSON representation of a span. */\nfunction getStatusMessage(status) {\n  if (!status || status.code === SPAN_STATUS_UNSET) {\n    return undefined;\n  }\n\n  if (status.code === SPAN_STATUS_OK) {\n    return 'ok';\n  }\n\n  return status.message || 'unknown_error';\n}\n\nconst CHILD_SPANS_FIELD = '_sentryChildSpans';\nconst ROOT_SPAN_FIELD = '_sentryRootSpan';\n\n/**\n * Adds an opaque child span reference to a span.\n */\nfunction addChildSpanToSpan(span, childSpan) {\n  // We store the root span reference on the child span\n  // We need this for `getRootSpan()` to work\n  const rootSpan = span[ROOT_SPAN_FIELD] || span;\n  addNonEnumerableProperty(childSpan , ROOT_SPAN_FIELD, rootSpan);\n\n  // We store a list of child spans on the parent span\n  // We need this for `getSpanDescendants()` to work\n  if (span[CHILD_SPANS_FIELD]) {\n    span[CHILD_SPANS_FIELD].add(childSpan);\n  } else {\n    addNonEnumerableProperty(span, CHILD_SPANS_FIELD, new Set([childSpan]));\n  }\n}\n\n/** This is only used internally by Idle Spans. */\nfunction removeChildSpanFromSpan(span, childSpan) {\n  if (span[CHILD_SPANS_FIELD]) {\n    span[CHILD_SPANS_FIELD].delete(childSpan);\n  }\n}\n\n/**\n * Returns an array of the given span and all of its descendants.\n */\nfunction getSpanDescendants(span) {\n  const resultSet = new Set();\n\n  function addSpanChildren(span) {\n    // This exit condition is required to not infinitely loop in case of a circular dependency.\n    if (resultSet.has(span)) {\n      return;\n      // We want to ignore unsampled spans (e.g. non recording spans)\n    } else if (spanIsSampled(span)) {\n      resultSet.add(span);\n      const childSpans = span[CHILD_SPANS_FIELD] ? Array.from(span[CHILD_SPANS_FIELD]) : [];\n      for (const childSpan of childSpans) {\n        addSpanChildren(childSpan);\n      }\n    }\n  }\n\n  addSpanChildren(span);\n\n  return Array.from(resultSet);\n}\n\n/**\n * Returns the root span of a given span.\n */\nfunction getRootSpan(span) {\n  return span[ROOT_SPAN_FIELD] || span;\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  if (acs.getActiveSpan) {\n    return acs.getActiveSpan();\n  }\n\n  return _getSpanForScope(getCurrentScope());\n}\n\n/**\n * Logs a warning once if `beforeSendSpan` is used to drop spans.\n */\nfunction showSpanDropWarning() {\n  if (!hasShownSpanDropWarning) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly.',\n      );\n    });\n    hasShownSpanDropWarning = true;\n  }\n}\n\n/**\n * Updates the name of the given span and ensures that the span name is not\n * overwritten by the Sentry SDK.\n *\n * Use this function instead of `span.updateName()` if you want to make sure that\n * your name is kept. For some spans, for example root `http.server` spans the\n * Sentry SDK would otherwise overwrite the span name with a high-quality name\n * it infers when the span ends.\n *\n * Use this function in server code or when your span is started on the server\n * and on the client (browser). If you only update a span name on the client,\n * you can also use `span.updateName()` the SDK does not overwrite the name.\n *\n * @param span - The span to update the name of.\n * @param name - The name to set on the span.\n */\nfunction updateSpanName(span, name) {\n  span.updateName(name);\n  span.setAttributes({\n    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'custom',\n    [SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME]: name,\n  });\n}\n\nexport { TRACE_FLAG_NONE, TRACE_FLAG_SAMPLED, addChildSpanToSpan, convertSpanLinksForEnvelope, getActiveSpan, getRootSpan, getSpanDescendants, getStatusMessage, removeChildSpanFromSpan, showSpanDropWarning, spanIsSampled, spanTimeInputToSeconds, spanToJSON, spanToTraceContext, spanToTraceHeader, spanToTransactionTraceContext, updateSpanName };\n//# sourceMappingURL=spanUtils.js.map\n"],"names":["TRACE_FLAG_NONE","TRACE_FLAG_SAMPLED","hasShownSpanDropWarning","spanToTransactionTraceContext","span","span_id","trace_id","data","op","parent_span_id","status","origin","links","spanToJSON","spanToTraceContext","spanId","isRemote","scope","getCapturedScopesOnSpan","generateSpanId","spanToTraceHeader","traceId","sampled","spanIsSampled","generateSentryTraceHeader","convertSpanLinksForEnvelope","traceFlags","restContext","attributes","spanTimeInputToSeconds","input","ensureTimestampInSeconds","timestampInSeconds","timestamp","spanIsSentrySpan","spanIsOpenTelemetrySdkTraceBaseSpan","startTime","name","endTime","parentSpanId","getStatusMessage","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","castSpan","SPAN_STATUS_UNSET","SPAN_STATUS_OK","CHILD_SPANS_FIELD","ROOT_SPAN_FIELD","addChildSpanToSpan","childSpan","rootSpan","addNonEnumerableProperty","removeChildSpanFromSpan","getSpanDescendants","resultSet","addSpanChildren","childSpans","getRootSpan","getActiveSpan","carrier","getMainCarrier","acs","getAsyncContextStrategy","_getSpanForScope","getCurrentScope","showSpanDropWarning","consoleSandbox"],"mappings":"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","x_google_ignoreList":[0]}