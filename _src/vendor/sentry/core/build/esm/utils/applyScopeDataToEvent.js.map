{"version":3,"file":"applyScopeDataToEvent.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/utils/applyScopeDataToEvent.js"],"sourcesContent":["import { getDynamicSamplingContextFromSpan } from '../tracing/dynamicSamplingContext.js';\nimport { merge } from './merge.js';\nimport { spanToTraceContext, getRootSpan, spanToJSON } from './spanUtils.js';\n\n/**\n * Applies data from the scope to the event and runs all event processors on it.\n */\nfunction applyScopeDataToEvent(event, data) {\n  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;\n\n  // Apply general data\n  applyDataToEvent(event, data);\n\n  // We want to set the trace context for normal events only if there isn't already\n  // a trace context on the event. There is a product feature in place where we link\n  // errors with transaction and it relies on that.\n  if (span) {\n    applySpanToEvent(event, span);\n  }\n\n  applyFingerprintToEvent(event, fingerprint);\n  applyBreadcrumbsToEvent(event, breadcrumbs);\n  applySdkMetadataToEvent(event, sdkProcessingMetadata);\n}\n\n/** Merge data of two scopes together. */\nfunction mergeScopeData(data, mergeData) {\n  const {\n    extra,\n    tags,\n    user,\n    contexts,\n    level,\n    sdkProcessingMetadata,\n    breadcrumbs,\n    fingerprint,\n    eventProcessors,\n    attachments,\n    propagationContext,\n    transactionName,\n    span,\n  } = mergeData;\n\n  mergeAndOverwriteScopeData(data, 'extra', extra);\n  mergeAndOverwriteScopeData(data, 'tags', tags);\n  mergeAndOverwriteScopeData(data, 'user', user);\n  mergeAndOverwriteScopeData(data, 'contexts', contexts);\n\n  data.sdkProcessingMetadata = merge(data.sdkProcessingMetadata, sdkProcessingMetadata, 2);\n\n  if (level) {\n    data.level = level;\n  }\n\n  if (transactionName) {\n    data.transactionName = transactionName;\n  }\n\n  if (span) {\n    data.span = span;\n  }\n\n  if (breadcrumbs.length) {\n    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];\n  }\n\n  if (fingerprint.length) {\n    data.fingerprint = [...data.fingerprint, ...fingerprint];\n  }\n\n  if (eventProcessors.length) {\n    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];\n  }\n\n  if (attachments.length) {\n    data.attachments = [...data.attachments, ...attachments];\n  }\n\n  data.propagationContext = { ...data.propagationContext, ...propagationContext };\n}\n\n/**\n * Merges certain scope data. Undefined values will overwrite any existing values.\n * Exported only for tests.\n */\nfunction mergeAndOverwriteScopeData\n\n(data, prop, mergeVal) {\n  data[prop] = merge(data[prop], mergeVal, 1);\n}\n\nfunction applyDataToEvent(event, data) {\n  const { extra, tags, user, contexts, level, transactionName } = data;\n\n  if (Object.keys(extra).length) {\n    event.extra = { ...extra, ...event.extra };\n  }\n\n  if (Object.keys(tags).length) {\n    event.tags = { ...tags, ...event.tags };\n  }\n\n  if (Object.keys(user).length) {\n    event.user = { ...user, ...event.user };\n  }\n\n  if (Object.keys(contexts).length) {\n    event.contexts = { ...contexts, ...event.contexts };\n  }\n\n  if (level) {\n    event.level = level;\n  }\n\n  // transaction events get their `transaction` from the root span name\n  if (transactionName && event.type !== 'transaction') {\n    event.transaction = transactionName;\n  }\n}\n\nfunction applyBreadcrumbsToEvent(event, breadcrumbs) {\n  const mergedBreadcrumbs = [...(event.breadcrumbs || []), ...breadcrumbs];\n  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;\n}\n\nfunction applySdkMetadataToEvent(event, sdkProcessingMetadata) {\n  event.sdkProcessingMetadata = {\n    ...event.sdkProcessingMetadata,\n    ...sdkProcessingMetadata,\n  };\n}\n\nfunction applySpanToEvent(event, span) {\n  event.contexts = {\n    trace: spanToTraceContext(span),\n    ...event.contexts,\n  };\n\n  event.sdkProcessingMetadata = {\n    dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),\n    ...event.sdkProcessingMetadata,\n  };\n\n  const rootSpan = getRootSpan(span);\n  const transactionName = spanToJSON(rootSpan).description;\n  if (transactionName && !event.transaction && event.type === 'transaction') {\n    event.transaction = transactionName;\n  }\n}\n\n/**\n * Applies fingerprint from the scope to the event if there's one,\n * uses message if there's one instead or get rid of empty fingerprint\n */\nfunction applyFingerprintToEvent(event, fingerprint) {\n  // Make sure it's an array first and we actually have something in place\n  event.fingerprint = event.fingerprint\n    ? Array.isArray(event.fingerprint)\n      ? event.fingerprint\n      : [event.fingerprint]\n    : [];\n\n  // If we have something on the scope, then merge it with event\n  if (fingerprint) {\n    event.fingerprint = event.fingerprint.concat(fingerprint);\n  }\n\n  // If we have no data at all, remove empty array default\n  if (!event.fingerprint.length) {\n    delete event.fingerprint;\n  }\n}\n\nexport { applyScopeDataToEvent, mergeAndOverwriteScopeData, mergeScopeData };\n//# sourceMappingURL=applyScopeDataToEvent.js.map\n"],"names":["applyScopeDataToEvent","event","data","fingerprint","span","breadcrumbs","sdkProcessingMetadata","applyDataToEvent","applySpanToEvent","applyFingerprintToEvent","applyBreadcrumbsToEvent","applySdkMetadataToEvent","mergeScopeData","mergeData","extra","tags","user","contexts","level","eventProcessors","attachments","propagationContext","transactionName","mergeAndOverwriteScopeData","merge","prop","mergeVal","mergedBreadcrumbs","spanToTraceContext","getDynamicSamplingContextFromSpan","rootSpan","getRootSpan","spanToJSON"],"mappings":"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","x_google_ignoreList":[0]}