{"version":3,"file":"traceData.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/utils/traceData.js"],"sourcesContent":["import { getAsyncContextStrategy } from '../asyncContext/index.js';\nimport { getMainCarrier } from '../carrier.js';\nimport { getClient, getCurrentScope } from '../currentScopes.js';\nimport { isEnabled } from '../exports.js';\nimport '../tracing/errors.js';\nimport '../debug-build.js';\nimport { logger } from '../utils-hoist/logger.js';\nimport { getActiveSpan, spanToTraceHeader } from './spanUtils.js';\nimport '../utils-hoist/time.js';\nimport { getDynamicSamplingContextFromSpan, getDynamicSamplingContextFromScope } from '../tracing/dynamicSamplingContext.js';\nimport { TRACEPARENT_REGEXP, generateSentryTraceHeader } from '../utils-hoist/tracing.js';\nimport { dynamicSamplingContextToSentryBaggageHeader } from '../utils-hoist/baggage.js';\n\n/**\n * Extracts trace propagation data from the current span or from the client's scope (via transaction or propagation\n * context) and serializes it to `sentry-trace` and `baggage` values to strings. These values can be used to propagate\n * a trace via our tracing Http headers or Html `<meta>` tags.\n *\n * This function also applies some validation to the generated sentry-trace and baggage values to ensure that\n * only valid strings are returned.\n *\n * @returns an object with the tracing data values. The object keys are the name of the tracing key to be used as header\n * or meta tag name.\n */\nfunction getTraceData(options = {}) {\n  const client = getClient();\n  if (!isEnabled() || !client) {\n    return {};\n  }\n\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  if (acs.getTraceData) {\n    return acs.getTraceData(options);\n  }\n\n  const scope = getCurrentScope();\n  const span = options.span || getActiveSpan();\n  const sentryTrace = span ? spanToTraceHeader(span) : scopeToTraceHeader(scope);\n  const dsc = span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromScope(client, scope);\n  const baggage = dynamicSamplingContextToSentryBaggageHeader(dsc);\n\n  const isValidSentryTraceHeader = TRACEPARENT_REGEXP.test(sentryTrace);\n  if (!isValidSentryTraceHeader) {\n    logger.warn('Invalid sentry-trace data. Cannot generate trace data');\n    return {};\n  }\n\n  return {\n    'sentry-trace': sentryTrace,\n    baggage,\n  };\n}\n\n/**\n * Get a sentry-trace header value for the given scope.\n */\nfunction scopeToTraceHeader(scope) {\n  const { traceId, sampled, propagationSpanId } = scope.getPropagationContext();\n  return generateSentryTraceHeader(traceId, propagationSpanId, sampled);\n}\n\nexport { getTraceData };\n//# sourceMappingURL=traceData.js.map\n"],"names":["getTraceData","options","client","getClient","isEnabled","carrier","getMainCarrier","acs","getAsyncContextStrategy","scope","getCurrentScope","span","getActiveSpan","sentryTrace","spanToTraceHeader","scopeToTraceHeader","dsc","getDynamicSamplingContextFromSpan","getDynamicSamplingContextFromScope","baggage","dynamicSamplingContextToSentryBaggageHeader","TRACEPARENT_REGEXP","logger","traceId","sampled","propagationSpanId","generateSentryTraceHeader"],"mappings":"gpBAwBA,SAASA,EAAaC,EAAU,GAAI,CAClC,MAAMC,EAASC,EAAW,EAC1B,GAAI,CAACC,KAAe,CAACF,EACnB,MAAO,CAAE,EAGX,MAAMG,EAAUC,EAAgB,EAC1BC,EAAMC,EAAwBH,CAAO,EAC3C,GAAIE,EAAI,aACN,OAAOA,EAAI,aAAaN,CAAO,EAGjC,MAAMQ,EAAQC,EAAiB,EACzBC,EAAOV,EAAQ,MAAQW,EAAe,EACtCC,EAAcF,EAAOG,EAAkBH,CAAI,EAAII,EAAmBN,CAAK,EACvEO,EAAML,EAAOM,EAAkCN,CAAI,EAAIO,EAAmChB,EAAQO,CAAK,EACvGU,EAAUC,EAA4CJ,CAAG,EAG/D,OADiCK,EAAmB,KAAKR,CAAW,EAM7D,CACL,eAAgBA,EAChB,QAAAM,CACD,GAPCG,EAAO,KAAK,uDAAuD,EAC5D,CAAE,EAOb,CAKA,SAASP,EAAmBN,EAAO,CACjC,KAAM,CAAE,QAAAc,EAAS,QAAAC,EAAS,kBAAAC,CAAiB,EAAKhB,EAAM,sBAAuB,EAC7E,OAAOiB,EAA0BH,EAASE,EAAmBD,CAAO,CACtE","x_google_ignoreList":[0]}