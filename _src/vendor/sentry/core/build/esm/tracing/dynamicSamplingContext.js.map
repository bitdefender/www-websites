{"version":3,"file":"dynamicSamplingContext.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js"],"sourcesContent":["import { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { getClient } from '../currentScopes.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '../semanticAttributes.js';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled.js';\nimport { getRootSpan, spanToJSON, spanIsSampled } from '../utils/spanUtils.js';\nimport { baggageHeaderToDynamicSamplingContext, dynamicSamplingContextToSentryBaggageHeader } from '../utils-hoist/baggage.js';\nimport { addNonEnumerableProperty } from '../utils-hoist/object.js';\nimport { getCapturedScopesOnSpan } from './utils.js';\n\n/**\n * If you change this value, also update the terser plugin config to\n * avoid minification of the object property!\n */\nconst FROZEN_DSC_FIELD = '_frozenDsc';\n\n/**\n * Freeze the given DSC on the given span.\n */\nfunction freezeDscOnSpan(span, dsc) {\n  const spanWithMaybeDsc = span ;\n  addNonEnumerableProperty(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);\n}\n\n/**\n * Creates a dynamic sampling context from a client.\n *\n * Dispatches the `createDsc` lifecycle hook as a side effect.\n */\nfunction getDynamicSamplingContextFromClient(trace_id, client) {\n  const options = client.getOptions();\n\n  const { publicKey: public_key } = client.getDsn() || {};\n\n  // Instead of conditionally adding non-undefined values, we add them and then remove them if needed\n  // otherwise, the order of baggage entries changes, which \"breaks\" a bunch of tests etc.\n  const dsc = {\n    environment: options.environment || DEFAULT_ENVIRONMENT,\n    release: options.release,\n    public_key,\n    trace_id,\n  };\n\n  client.emit('createDsc', dsc);\n\n  return dsc;\n}\n\n/**\n * Get the dynamic sampling context for the currently active scopes.\n */\nfunction getDynamicSamplingContextFromScope(client, scope) {\n  const propagationContext = scope.getPropagationContext();\n  return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);\n}\n\n/**\n * Creates a dynamic sampling context from a span (and client and scope)\n *\n * @param span the span from which a few values like the root span name and sample rate are extracted.\n *\n * @returns a dynamic sampling context\n */\nfunction getDynamicSamplingContextFromSpan(span) {\n  const client = getClient();\n  if (!client) {\n    return {};\n  }\n\n  const rootSpan = getRootSpan(span);\n  const rootSpanJson = spanToJSON(rootSpan);\n  const rootSpanAttributes = rootSpanJson.data;\n  const traceState = rootSpan.spanContext().traceState;\n\n  // The span sample rate that was locally applied to the root span should also always be applied to the DSC, even if the DSC is frozen.\n  // This is so that the downstream traces/services can use parentSampleRate in their `tracesSampler` to make consistent sampling decisions across the entire trace.\n  const rootSpanSampleRate =\n    traceState?.get('sentry.sample_rate') ??\n    rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ??\n    rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE];\n\n  function applyLocalSampleRateToDsc(dsc) {\n    if (typeof rootSpanSampleRate === 'number' || typeof rootSpanSampleRate === 'string') {\n      dsc.sample_rate = `${rootSpanSampleRate}`;\n    }\n    return dsc;\n  }\n\n  // For core implementation, we freeze the DSC onto the span as a non-enumerable property\n  const frozenDsc = (rootSpan )[FROZEN_DSC_FIELD];\n  if (frozenDsc) {\n    return applyLocalSampleRateToDsc(frozenDsc);\n  }\n\n  // For OpenTelemetry, we freeze the DSC on the trace state\n  const traceStateDsc = traceState?.get('sentry.dsc');\n\n  // If the span has a DSC, we want it to take precedence\n  const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);\n\n  if (dscOnTraceState) {\n    return applyLocalSampleRateToDsc(dscOnTraceState);\n  }\n\n  // Else, we generate it from the span\n  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);\n\n  // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n  const source = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n  // after JSON conversion, txn.name becomes jsonSpan.description\n  const name = rootSpanJson.description;\n  if (source !== 'url' && name) {\n    dsc.transaction = name;\n  }\n\n  // How can we even land here with hasSpansEnabled() returning false?\n  // Otel creates a Non-recording span in Tracing Without Performance mode when handling incoming requests\n  // So we end up with an active span that is not sampled (neither positively nor negatively)\n  if (hasSpansEnabled()) {\n    dsc.sampled = String(spanIsSampled(rootSpan));\n    dsc.sample_rand =\n      // In OTEL we store the sample rand on the trace state because we cannot access scopes for NonRecordingSpans\n      // The Sentry OTEL SpanSampler takes care of writing the sample rand on the root span\n      traceState?.get('sentry.sample_rand') ??\n      // On all other platforms we can actually get the scopes from a root span (we use this as a fallback)\n      getCapturedScopesOnSpan(rootSpan).scope?.getPropagationContext().sampleRand.toString();\n  }\n\n  applyLocalSampleRateToDsc(dsc);\n\n  client.emit('createDsc', dsc, rootSpan);\n\n  return dsc;\n}\n\n/**\n * Convert a Span to a baggage header.\n */\nfunction spanToBaggageHeader(span) {\n  const dsc = getDynamicSamplingContextFromSpan(span);\n  return dynamicSamplingContextToSentryBaggageHeader(dsc);\n}\n\nexport { freezeDscOnSpan, getDynamicSamplingContextFromClient, getDynamicSamplingContextFromScope, getDynamicSamplingContextFromSpan, spanToBaggageHeader };\n//# sourceMappingURL=dynamicSamplingContext.js.map\n"],"names":["FROZEN_DSC_FIELD","freezeDscOnSpan","span","dsc","addNonEnumerableProperty","getDynamicSamplingContextFromClient","trace_id","client","options","public_key","DEFAULT_ENVIRONMENT","getDynamicSamplingContextFromScope","scope","propagationContext","getDynamicSamplingContextFromSpan","getClient","rootSpan","getRootSpan","rootSpanJson","spanToJSON","rootSpanAttributes","traceState","rootSpanSampleRate","SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE","SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE","applyLocalSampleRateToDsc","frozenDsc","traceStateDsc","dscOnTraceState","baggageHeaderToDynamicSamplingContext","source","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","name","hasSpansEnabled","spanIsSampled","getCapturedScopesOnSpan"],"mappings":"unBAaA,MAAMA,EAAmB,aAKzB,SAASC,EAAgBC,EAAMC,EAAK,CAElCC,EADyBF,EACkBF,EAAkBG,CAAG,CAClE,CAOA,SAASE,EAAoCC,EAAUC,EAAQ,CAC7D,MAAMC,EAAUD,EAAO,WAAY,EAE7B,CAAE,UAAWE,CAAU,EAAKF,EAAO,OAAQ,GAAI,CAAE,EAIjDJ,EAAM,CACV,YAAaK,EAAQ,aAAeE,EACpC,QAASF,EAAQ,QACjB,WAAAC,EACA,SAAAH,CACD,EAED,OAAAC,EAAO,KAAK,YAAaJ,CAAG,EAErBA,CACT,CAKA,SAASQ,EAAmCJ,EAAQK,EAAO,CACzD,MAAMC,EAAqBD,EAAM,sBAAuB,EACxD,OAAOC,EAAmB,KAAOR,EAAoCQ,EAAmB,QAASN,CAAM,CACzG,CASA,SAASO,EAAkCZ,EAAM,CAC/C,MAAMK,EAASQ,EAAW,EAC1B,GAAI,CAACR,EACH,MAAO,CAAE,EAGX,MAAMS,EAAWC,EAAYf,CAAI,EAC3BgB,EAAeC,EAAWH,CAAQ,EAClCI,EAAqBF,EAAa,KAClCG,EAAaL,EAAS,YAAW,EAAG,WAIpCM,EACJD,GAAY,IAAI,oBAAoB,GACpCD,EAAmBG,CAAqC,GACxDH,EAAmBI,CAAoD,EAEzE,SAASC,EAA0BtB,EAAK,CACtC,OAAI,OAAOmB,GAAuB,UAAY,OAAOA,GAAuB,YAC1EnB,EAAI,YAAc,GAAGmB,CAAkB,IAElCnB,CACX,CAGE,MAAMuB,EAAaV,EAAWhB,CAAgB,EAC9C,GAAI0B,EACF,OAAOD,EAA0BC,CAAS,EAI5C,MAAMC,EAAgBN,GAAY,IAAI,YAAY,EAG5CO,EAAkBD,GAAiBE,EAAsCF,CAAa,EAE5F,GAAIC,EACF,OAAOH,EAA0BG,CAAe,EAIlD,MAAMzB,EAAME,EAAoCH,EAAK,YAAa,EAAC,QAASK,CAAM,EAG5EuB,EAASV,EAAmBW,CAAgC,EAG5DC,EAAOd,EAAa,YAC1B,OAAIY,IAAW,OAASE,IACtB7B,EAAI,YAAc6B,GAMhBC,EAAe,IACjB9B,EAAI,QAAU,OAAO+B,EAAclB,CAAQ,CAAC,EAC5Cb,EAAI,YAGFkB,GAAY,IAAI,oBAAoB,GAEpCc,EAAwBnB,CAAQ,EAAE,OAAO,sBAAuB,EAAC,WAAW,SAAU,GAG1FS,EAA0BtB,CAAG,EAE7BI,EAAO,KAAK,YAAaJ,EAAKa,CAAQ,EAE/Bb,CACT","x_google_ignoreList":[0]}