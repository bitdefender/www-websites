{"version":3,"file":"sentrySpan.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/tracing/sentrySpan.js"],"sourcesContent":["import { getClient, getCurrentScope } from '../currentScopes.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { createSpanEnvelope } from '../envelope.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME, SEMANTIC_ATTRIBUTE_PROFILE_ID, SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME } from '../semanticAttributes.js';\nimport { TRACE_FLAG_SAMPLED, TRACE_FLAG_NONE, spanTimeInputToSeconds, convertSpanLinksForEnvelope, getRootSpan, getStatusMessage, spanToJSON, getSpanDescendants, spanToTransactionTraceContext } from '../utils/spanUtils.js';\nimport { logger } from '../utils-hoist/logger.js';\nimport { generateTraceId, generateSpanId } from '../utils-hoist/propagationContext.js';\nimport { timestampInSeconds } from '../utils-hoist/time.js';\nimport { getDynamicSamplingContextFromSpan } from './dynamicSamplingContext.js';\nimport { logSpanEnd } from './logSpans.js';\nimport { timedEventsToMeasurements } from './measurement.js';\nimport { getCapturedScopesOnSpan } from './utils.js';\n\nconst MAX_SPAN_COUNT = 1000;\n\n/**\n * Span contains all data about a span\n */\nclass SentrySpan  {\n\n  /** Epoch timestamp in seconds when the span started. */\n\n  /** Epoch timestamp in seconds when the span ended. */\n\n  /** Internal keeper of the status */\n\n  /** The timed events added to this span. */\n\n  /** if true, treat span as a standalone span (not part of a transaction) */\n\n  /**\n   * You should never call the constructor manually, always use `Sentry.startSpan()`\n   * or other span methods.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n   constructor(spanContext = {}) {\n    this._traceId = spanContext.traceId || generateTraceId();\n    this._spanId = spanContext.spanId || generateSpanId();\n    this._startTime = spanContext.startTimestamp || timestampInSeconds();\n    this._links = spanContext.links;\n\n    this._attributes = {};\n    this.setAttributes({\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'manual',\n      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,\n      ...spanContext.attributes,\n    });\n\n    this._name = spanContext.name;\n\n    if (spanContext.parentSpanId) {\n      this._parentSpanId = spanContext.parentSpanId;\n    }\n    // We want to include booleans as well here\n    if ('sampled' in spanContext) {\n      this._sampled = spanContext.sampled;\n    }\n    if (spanContext.endTimestamp) {\n      this._endTime = spanContext.endTimestamp;\n    }\n\n    this._events = [];\n\n    this._isStandaloneSpan = spanContext.isStandalone;\n\n    // If the span is already ended, ensure we finalize the span immediately\n    if (this._endTime) {\n      this._onSpanEnded();\n    }\n  }\n\n  /** @inheritDoc */\n   addLink(link) {\n    if (this._links) {\n      this._links.push(link);\n    } else {\n      this._links = [link];\n    }\n    return this;\n  }\n\n  /** @inheritDoc */\n   addLinks(links) {\n    if (this._links) {\n      this._links.push(...links);\n    } else {\n      this._links = links;\n    }\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but it is needed for being compliant with the OTEL Span interface.\n   *\n   * @hidden\n   * @internal\n   */\n   recordException(_exception, _time) {\n    // noop\n  }\n\n  /** @inheritdoc */\n   spanContext() {\n    const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;\n    return {\n      spanId,\n      traceId,\n      traceFlags: sampled ? TRACE_FLAG_SAMPLED : TRACE_FLAG_NONE,\n    };\n  }\n\n  /** @inheritdoc */\n   setAttribute(key, value) {\n    if (value === undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._attributes[key];\n    } else {\n      this._attributes[key] = value;\n    }\n\n    return this;\n  }\n\n  /** @inheritdoc */\n   setAttributes(attributes) {\n    Object.keys(attributes).forEach(key => this.setAttribute(key, attributes[key]));\n    return this;\n  }\n\n  /**\n   * This should generally not be used,\n   * but we need it for browser tracing where we want to adjust the start time afterwards.\n   * USE THIS WITH CAUTION!\n   *\n   * @hidden\n   * @internal\n   */\n   updateStartTime(timeInput) {\n    this._startTime = spanTimeInputToSeconds(timeInput);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setStatus(value) {\n    this._status = value;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   updateName(name) {\n    this._name = name;\n    this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'custom');\n    return this;\n  }\n\n  /** @inheritdoc */\n   end(endTimestamp) {\n    // If already ended, skip\n    if (this._endTime) {\n      return;\n    }\n\n    this._endTime = spanTimeInputToSeconds(endTimestamp);\n    logSpanEnd(this);\n\n    this._onSpanEnded();\n  }\n\n  /**\n   * Get JSON representation of this span.\n   *\n   * @hidden\n   * @internal This method is purely for internal purposes and should not be used outside\n   * of SDK code. If you need to get a JSON representation of a span,\n   * use `spanToJSON(span)` instead.\n   */\n   getSpanJSON() {\n    return {\n      data: this._attributes,\n      description: this._name,\n      op: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],\n      parent_span_id: this._parentSpanId,\n      span_id: this._spanId,\n      start_timestamp: this._startTime,\n      status: getStatusMessage(this._status),\n      timestamp: this._endTime,\n      trace_id: this._traceId,\n      origin: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ,\n      profile_id: this._attributes[SEMANTIC_ATTRIBUTE_PROFILE_ID] ,\n      exclusive_time: this._attributes[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME] ,\n      measurements: timedEventsToMeasurements(this._events),\n      is_segment: (this._isStandaloneSpan && getRootSpan(this) === this) || undefined,\n      segment_id: this._isStandaloneSpan ? getRootSpan(this).spanContext().spanId : undefined,\n      links: convertSpanLinksForEnvelope(this._links),\n    };\n  }\n\n  /** @inheritdoc */\n   isRecording() {\n    return !this._endTime && !!this._sampled;\n  }\n\n  /**\n   * @inheritdoc\n   */\n   addEvent(\n    name,\n    attributesOrStartTime,\n    startTime,\n  ) {\n    DEBUG_BUILD && logger.log('[Tracing] Adding an event to span:', name);\n\n    const time = isSpanTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime || timestampInSeconds();\n    const attributes = isSpanTimeInput(attributesOrStartTime) ? {} : attributesOrStartTime || {};\n\n    const event = {\n      name,\n      time: spanTimeInputToSeconds(time),\n      attributes,\n    };\n\n    this._events.push(event);\n\n    return this;\n  }\n\n  /**\n   * This method should generally not be used,\n   * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.\n   * USE THIS WITH CAUTION!\n   * @internal\n   * @hidden\n   * @experimental\n   */\n   isStandaloneSpan() {\n    return !!this._isStandaloneSpan;\n  }\n\n  /** Emit `spanEnd` when the span is ended. */\n   _onSpanEnded() {\n    const client = getClient();\n    if (client) {\n      client.emit('spanEnd', this);\n    }\n\n    // A segment span is basically the root span of a local span tree.\n    // So for now, this is either what we previously refer to as the root span,\n    // or a standalone span.\n    const isSegmentSpan = this._isStandaloneSpan || this === getRootSpan(this);\n\n    if (!isSegmentSpan) {\n      return;\n    }\n\n    // if this is a standalone span, we send it immediately\n    if (this._isStandaloneSpan) {\n      if (this._sampled) {\n        sendSpanEnvelope(createSpanEnvelope([this], client));\n      } else {\n        DEBUG_BUILD &&\n          logger.log('[Tracing] Discarding standalone span because its trace was not chosen to be sampled.');\n        if (client) {\n          client.recordDroppedEvent('sample_rate', 'span');\n        }\n      }\n      return;\n    }\n\n    const transactionEvent = this._convertSpanToTransaction();\n    if (transactionEvent) {\n      const scope = getCapturedScopesOnSpan(this).scope || getCurrentScope();\n      scope.captureEvent(transactionEvent);\n    }\n  }\n\n  /**\n   * Finish the transaction & prepare the event to send to Sentry.\n   */\n   _convertSpanToTransaction() {\n    // We can only convert finished spans\n    if (!isFullFinishedSpan(spanToJSON(this))) {\n      return undefined;\n    }\n\n    if (!this._name) {\n      DEBUG_BUILD && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this._name = '<unlabeled transaction>';\n    }\n\n    const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = getCapturedScopesOnSpan(this);\n\n    if (this._sampled !== true) {\n      return undefined;\n    }\n\n    // The transaction span itself as well as any potential standalone spans should be filtered out\n    const finishedSpans = getSpanDescendants(this).filter(span => span !== this && !isStandaloneSpan(span));\n\n    const spans = finishedSpans.map(span => spanToJSON(span)).filter(isFullFinishedSpan);\n\n    const source = this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ;\n\n    // remove internal root span attributes we don't need to send.\n    /* eslint-disable @typescript-eslint/no-dynamic-delete */\n    delete this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n    spans.forEach(span => {\n      delete span.data[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n    });\n    // eslint-enabled-next-line @typescript-eslint/no-dynamic-delete\n\n    const transaction = {\n      contexts: {\n        trace: spanToTransactionTraceContext(this),\n      },\n      spans:\n        // spans.sort() mutates the array, but `spans` is already a copy so we can safely do this here\n        // we do not use spans anymore after this point\n        spans.length > MAX_SPAN_COUNT\n          ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n          : spans,\n      start_timestamp: this._startTime,\n      timestamp: this._endTime,\n      transaction: this._name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        capturedSpanScope,\n        capturedSpanIsolationScope,\n        dynamicSamplingContext: getDynamicSamplingContextFromSpan(this),\n      },\n      ...(source && {\n        transaction_info: {\n          source,\n        },\n      }),\n    };\n\n    const measurements = timedEventsToMeasurements(this._events);\n    const hasMeasurements = measurements && Object.keys(measurements).length;\n\n    if (hasMeasurements) {\n      DEBUG_BUILD &&\n        logger.log(\n          '[Measurements] Adding measurements to transaction event',\n          JSON.stringify(measurements, undefined, 2),\n        );\n      transaction.measurements = measurements;\n    }\n\n    return transaction;\n  }\n}\n\nfunction isSpanTimeInput(value) {\n  return (value && typeof value === 'number') || value instanceof Date || Array.isArray(value);\n}\n\n// We want to filter out any incomplete SpanJSON objects\nfunction isFullFinishedSpan(input) {\n  return !!input.start_timestamp && !!input.timestamp && !!input.span_id && !!input.trace_id;\n}\n\n/** `SentrySpan`s can be sent as a standalone span rather than belonging to a transaction */\nfunction isStandaloneSpan(span) {\n  return span instanceof SentrySpan && span.isStandaloneSpan();\n}\n\n/**\n * Sends a `SpanEnvelope`.\n *\n * Note: If the envelope's spans are dropped, e.g. via `beforeSendSpan`,\n * the envelope will not be sent either.\n */\nfunction sendSpanEnvelope(envelope) {\n  const client = getClient();\n  if (!client) {\n    return;\n  }\n\n  const spanItems = envelope[1];\n  if (!spanItems || spanItems.length === 0) {\n    client.recordDroppedEvent('before_send', 'span');\n    return;\n  }\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\n\nexport { SentrySpan };\n//# sourceMappingURL=sentrySpan.js.map\n"],"names":["MAX_SPAN_COUNT","SentrySpan","spanContext","generateTraceId","generateSpanId","timestampInSeconds","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","link","links","_exception","_time","spanId","traceId","sampled","TRACE_FLAG_SAMPLED","TRACE_FLAG_NONE","key","value","attributes","timeInput","spanTimeInputToSeconds","name","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","endTimestamp","logSpanEnd","getStatusMessage","SEMANTIC_ATTRIBUTE_PROFILE_ID","SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME","timedEventsToMeasurements","getRootSpan","convertSpanLinksForEnvelope","attributesOrStartTime","startTime","DEBUG_BUILD","logger","time","isSpanTimeInput","event","client","getClient","sendSpanEnvelope","createSpanEnvelope","transactionEvent","getCapturedScopesOnSpan","getCurrentScope","isFullFinishedSpan","spanToJSON","capturedSpanScope","capturedSpanIsolationScope","spans","getSpanDescendants","span","isStandaloneSpan","source","SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME","transaction","spanToTransactionTraceContext","a","b","getDynamicSamplingContextFromSpan","measurements","input","envelope","spanItems"],"mappings":"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","x_google_ignoreList":[0]}