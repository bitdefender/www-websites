{"version":3,"file":"browserTracingIntegration.js","sources":["../../../../../../../../node_modules/@sentry/browser/build/npm/esm/tracing/browserTracingIntegration.js"],"sourcesContent":["import { TRACING_DEFAULTS, registerSpanErrorInstrumentation, GLOBAL_OBJ, getLocationHref, getClient, getIsolationScope, generateTraceId, getCurrentScope, propagationContextFromHeaders, browserPerformanceTimeOrigin, spanToJSON, logger, SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, startIdleSpan, getDynamicSamplingContextFromSpan, spanIsSampled, addNonEnumerableProperty, consoleSandbox, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '@sentry/core';\nimport { startTrackingWebVitals, startTrackingINP, startTrackingLongAnimationFrames, startTrackingLongTasks, startTrackingInteractions, addHistoryInstrumentationHandler, registerInpInteractionListener, addPerformanceEntries } from '@sentry-internal/browser-utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { WINDOW } from '../helpers.js';\nimport { registerBackgroundTabDetection } from './backgroundtab.js';\nimport { linkTraces } from './linkedTraces.js';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request.js';\n\nconst BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS = {\n  ...TRACING_DEFAULTS,\n  instrumentNavigation: true,\n  instrumentPageLoad: true,\n  markBackgroundSpan: true,\n  enableLongTask: true,\n  enableLongAnimationFrame: true,\n  enableInp: true,\n  linkPreviousTrace: 'in-memory',\n  consistentTraceSampling: false,\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions,\n};\n\nlet _hasBeenInitialized = false;\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library.\n *\n * We explicitly export the proper type here, as this has to be extended in some cases.\n */\nconst browserTracingIntegration = ((_options = {}) => {\n  if (_hasBeenInitialized) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('Multiple browserTracingIntegration instances are not supported.');\n    });\n  }\n\n  _hasBeenInitialized = true;\n\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document ;\n\n  registerSpanErrorInstrumentation();\n\n  const {\n    enableInp,\n    enableLongTask,\n    enableLongAnimationFrame,\n    _experiments: { enableInteractions, enableStandaloneClsSpans },\n    beforeStartSpan,\n    idleTimeout,\n    finalTimeout,\n    childSpanTimeout,\n    markBackgroundSpan,\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    instrumentPageLoad,\n    instrumentNavigation,\n    linkPreviousTrace,\n    consistentTraceSampling,\n    onRequestSpanStart,\n  } = {\n    ...DEFAULT_BROWSER_TRACING_OPTIONS,\n    ..._options,\n  };\n\n  const _collectWebVitals = startTrackingWebVitals({ recordClsStandaloneSpans: enableStandaloneClsSpans || false });\n\n  if (enableInp) {\n    startTrackingINP();\n  }\n\n  if (\n    enableLongAnimationFrame &&\n    GLOBAL_OBJ.PerformanceObserver &&\n    PerformanceObserver.supportedEntryTypes &&\n    PerformanceObserver.supportedEntryTypes.includes('long-animation-frame')\n  ) {\n    startTrackingLongAnimationFrames();\n  } else if (enableLongTask) {\n    startTrackingLongTasks();\n  }\n\n  if (enableInteractions) {\n    startTrackingInteractions();\n  }\n\n  const latestRoute = {\n    name: undefined,\n    source: undefined,\n  };\n\n  /** Create routing idle transaction. */\n  function _createRouteSpan(client, startSpanOptions) {\n    const isPageloadTransaction = startSpanOptions.op === 'pageload';\n\n    const finalStartSpanOptions = beforeStartSpan\n      ? beforeStartSpan(startSpanOptions)\n      : startSpanOptions;\n\n    const attributes = finalStartSpanOptions.attributes || {};\n\n    // If `finalStartSpanOptions.name` is different than `startSpanOptions.name`\n    // it is because `beforeStartSpan` set a custom name. Therefore we set the source to 'custom'.\n    if (startSpanOptions.name !== finalStartSpanOptions.name) {\n      attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'custom';\n      finalStartSpanOptions.attributes = attributes;\n    }\n\n    latestRoute.name = finalStartSpanOptions.name;\n    latestRoute.source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    const idleSpan = startIdleSpan(finalStartSpanOptions, {\n      idleTimeout,\n      finalTimeout,\n      childSpanTimeout,\n      // should wait for finish signal if it's a pageload transaction\n      disableAutoFinish: isPageloadTransaction,\n      beforeSpanEnd: span => {\n        _collectWebVitals();\n        addPerformanceEntries(span, { recordClsOnPageloadSpan: !enableStandaloneClsSpans });\n        setActiveIdleSpan(client, undefined);\n\n        // A trace should stay consistent over the entire timespan of one route - even after the pageload/navigation ended.\n        // Only when another navigation happens, we want to create a new trace.\n        // This way, e.g. errors that occur after the pageload span ended are still associated to the pageload trace.\n        const scope = getCurrentScope();\n        const oldPropagationContext = scope.getPropagationContext();\n\n        scope.setPropagationContext({\n          ...oldPropagationContext,\n          traceId: idleSpan.spanContext().traceId,\n          sampled: spanIsSampled(idleSpan),\n          dsc: getDynamicSamplingContextFromSpan(span),\n        });\n      },\n    });\n\n    setActiveIdleSpan(client, idleSpan);\n\n    function emitFinish() {\n      if (optionalWindowDocument && ['interactive', 'complete'].includes(optionalWindowDocument.readyState)) {\n        client.emit('idleSpanEnableAutoFinish', idleSpan);\n      }\n    }\n\n    if (isPageloadTransaction && optionalWindowDocument) {\n      optionalWindowDocument.addEventListener('readystatechange', () => {\n        emitFinish();\n      });\n\n      emitFinish();\n    }\n  }\n\n  return {\n    name: BROWSER_TRACING_INTEGRATION_ID,\n    afterAllSetup(client) {\n      let startingUrl = getLocationHref();\n\n      function maybeEndActiveSpan() {\n        const activeSpan = getActiveIdleSpan(client);\n\n        if (activeSpan && !spanToJSON(activeSpan).timestamp) {\n          DEBUG_BUILD && logger.log(`[Tracing] Finishing current active span with op: ${spanToJSON(activeSpan).op}`);\n          // If there's an open active span, we need to finish it before creating an new one.\n          activeSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, 'cancelled');\n          activeSpan.end();\n        }\n      }\n\n      client.on('startNavigationSpan', startSpanOptions => {\n        if (getClient() !== client) {\n          return;\n        }\n\n        maybeEndActiveSpan();\n\n        getIsolationScope().setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });\n        getCurrentScope().setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });\n\n        _createRouteSpan(client, {\n          op: 'navigation',\n          ...startSpanOptions,\n        });\n      });\n\n      client.on('startPageLoadSpan', (startSpanOptions, traceOptions = {}) => {\n        if (getClient() !== client) {\n          return;\n        }\n        maybeEndActiveSpan();\n\n        const sentryTrace = traceOptions.sentryTrace || getMetaContent('sentry-trace');\n        const baggage = traceOptions.baggage || getMetaContent('baggage');\n\n        const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n        getCurrentScope().setPropagationContext(propagationContext);\n\n        _createRouteSpan(client, {\n          op: 'pageload',\n          ...startSpanOptions,\n        });\n      });\n\n      if (linkPreviousTrace !== 'off') {\n        linkTraces(client, { linkPreviousTrace, consistentTraceSampling });\n      }\n\n      if (WINDOW.location) {\n        if (instrumentPageLoad) {\n          const origin = browserPerformanceTimeOrigin();\n          startBrowserTracingPageLoadSpan(client, {\n            name: WINDOW.location.pathname,\n            // pageload should always start at timeOrigin (and needs to be in s, not ms)\n            startTime: origin ? origin / 1000 : undefined,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.browser',\n            },\n          });\n        }\n\n        if (instrumentNavigation) {\n          addHistoryInstrumentationHandler(({ to, from }) => {\n            /**\n             * This early return is there to account for some cases where a navigation transaction starts right after\n             * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n             * create an uneccessary navigation transaction.\n             *\n             * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n             * only be caused in certain development environments where the usage of a hot module reloader is causing\n             * errors.\n             */\n            if (from === undefined && startingUrl?.indexOf(to) !== -1) {\n              startingUrl = undefined;\n              return;\n            }\n\n            if (from !== to) {\n              startingUrl = undefined;\n              startBrowserTracingNavigationSpan(client, {\n                name: WINDOW.location.pathname,\n                attributes: {\n                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.browser',\n                },\n              });\n            }\n          });\n        }\n      }\n\n      if (markBackgroundSpan) {\n        registerBackgroundTabDetection();\n      }\n\n      if (enableInteractions) {\n        registerInteractionListener(client, idleTimeout, finalTimeout, childSpanTimeout, latestRoute);\n      }\n\n      if (enableInp) {\n        registerInpInteractionListener();\n      }\n\n      instrumentOutgoingRequests(client, {\n        traceFetch,\n        traceXHR,\n        trackFetchStreamPerformance,\n        tracePropagationTargets: client.getOptions().tracePropagationTargets,\n        shouldCreateSpanForRequest,\n        enableHTTPTimings,\n        onRequestSpanStart,\n      });\n    },\n  };\n}) ;\n\n/**\n * Manually start a page load span.\n * This will only do something if a browser tracing integration integration has been setup.\n *\n * If you provide a custom `traceOptions` object, it will be used to continue the trace\n * instead of the default behavior, which is to look it up on the <meta> tags.\n */\nfunction startBrowserTracingPageLoadSpan(\n  client,\n  spanOptions,\n  traceOptions,\n) {\n  client.emit('startPageLoadSpan', spanOptions, traceOptions);\n  getCurrentScope().setTransactionName(spanOptions.name);\n\n  return getActiveIdleSpan(client);\n}\n\n/**\n * Manually start a navigation span.\n * This will only do something if a browser tracing integration has been setup.\n */\nfunction startBrowserTracingNavigationSpan(client, spanOptions) {\n  client.emit('startNavigationSpan', spanOptions);\n\n  getCurrentScope().setTransactionName(spanOptions.name);\n\n  return getActiveIdleSpan(client);\n}\n\n/** Returns the value of a meta tag */\nfunction getMetaContent(metaName) {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document ;\n\n  const metaTag = optionalWindowDocument?.querySelector(`meta[name=${metaName}]`);\n  return metaTag?.getAttribute('content') || undefined;\n}\n\n/** Start listener for interaction transactions */\nfunction registerInteractionListener(\n  client,\n  idleTimeout,\n  finalTimeout,\n  childSpanTimeout,\n  latestRoute,\n) {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document ;\n\n  let inflightInteractionSpan;\n  const registerInteractionTransaction = () => {\n    const op = 'ui.action.click';\n\n    const activeIdleSpan = getActiveIdleSpan(client);\n    if (activeIdleSpan) {\n      const currentRootSpanOp = spanToJSON(activeIdleSpan).op;\n      if (['navigation', 'pageload'].includes(currentRootSpanOp )) {\n        DEBUG_BUILD &&\n          logger.warn(`[Tracing] Did not create ${op} span because a pageload or navigation span is in progress.`);\n        return undefined;\n      }\n    }\n\n    if (inflightInteractionSpan) {\n      inflightInteractionSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, 'interactionInterrupted');\n      inflightInteractionSpan.end();\n      inflightInteractionSpan = undefined;\n    }\n\n    if (!latestRoute.name) {\n      DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n      return undefined;\n    }\n\n    inflightInteractionSpan = startIdleSpan(\n      {\n        name: latestRoute.name,\n        op,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRoute.source || 'url',\n        },\n      },\n      {\n        idleTimeout,\n        finalTimeout,\n        childSpanTimeout,\n      },\n    );\n  };\n\n  if (optionalWindowDocument) {\n    addEventListener('click', registerInteractionTransaction, { once: false, capture: true });\n  }\n}\n\n// We store the active idle span on the client object, so we can access it from exported functions\nconst ACTIVE_IDLE_SPAN_PROPERTY = '_sentry_idleSpan';\nfunction getActiveIdleSpan(client) {\n  return (client )[ACTIVE_IDLE_SPAN_PROPERTY];\n}\n\nfunction setActiveIdleSpan(client, span) {\n  addNonEnumerableProperty(client, ACTIVE_IDLE_SPAN_PROPERTY, span);\n}\n\nexport { BROWSER_TRACING_INTEGRATION_ID, browserTracingIntegration, getMetaContent, startBrowserTracingNavigationSpan, startBrowserTracingPageLoadSpan };\n//# sourceMappingURL=browserTracingIntegration.js.map\n"],"names":["BROWSER_TRACING_INTEGRATION_ID","DEFAULT_BROWSER_TRACING_OPTIONS","TRACING_DEFAULTS","defaultRequestInstrumentationOptions","_hasBeenInitialized","browserTracingIntegration","_options","consoleSandbox","optionalWindowDocument","WINDOW","registerSpanErrorInstrumentation","enableInp","enableLongTask","enableLongAnimationFrame","enableInteractions","enableStandaloneClsSpans","beforeStartSpan","idleTimeout","finalTimeout","childSpanTimeout","markBackgroundSpan","traceFetch","traceXHR","trackFetchStreamPerformance","shouldCreateSpanForRequest","enableHTTPTimings","instrumentPageLoad","instrumentNavigation","linkPreviousTrace","consistentTraceSampling","onRequestSpanStart","_collectWebVitals","startTrackingWebVitals","startTrackingINP","GLOBAL_OBJ","startTrackingLongAnimationFrames","startTrackingLongTasks","startTrackingInteractions","latestRoute","_createRouteSpan","client","startSpanOptions","isPageloadTransaction","finalStartSpanOptions","attributes","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","idleSpan","startIdleSpan","span","addPerformanceEntries","setActiveIdleSpan","scope","getCurrentScope","oldPropagationContext","spanIsSampled","getDynamicSamplingContextFromSpan","emitFinish","startingUrl","getLocationHref","maybeEndActiveSpan","activeSpan","getActiveIdleSpan","spanToJSON","DEBUG_BUILD","logger","SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON","getClient","getIsolationScope","generateTraceId","traceOptions","sentryTrace","getMetaContent","baggage","propagationContext","propagationContextFromHeaders","linkTraces","origin","browserPerformanceTimeOrigin","startBrowserTracingPageLoadSpan","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","addHistoryInstrumentationHandler","to","from","startBrowserTracingNavigationSpan","registerBackgroundTabDetection","registerInteractionListener","registerInpInteractionListener","instrumentOutgoingRequests","spanOptions","metaName","inflightInteractionSpan","registerInteractionTransaction","op","activeIdleSpan","currentRootSpanOp","ACTIVE_IDLE_SPAN_PROPERTY","addNonEnumerableProperty"],"mappings":"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","x_google_ignoreList":[0]}