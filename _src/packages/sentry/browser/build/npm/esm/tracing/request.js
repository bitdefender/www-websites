import{WINDOW as b}from"../helpers.js";import{addFetchEndInstrumentationHandler as x,addFetchInstrumentationHandler as w}from"../../../../../core/build/esm/utils-hoist/instrument/fetch.js";import{addXhrInstrumentationHandler as A,SENTRY_XHR_DATA_KEY as O}from"../../../../../../sentry-internal/browser-utils/build/esm/instrument/xhr.js";import{instrumentFetchRequest as P}from"../../../../../core/build/esm/fetch.js";import{parseUrl as q,stripUrlQueryAndFragment as k}from"../../../../../core/build/esm/utils-hoist/url.js";import{spanToJSON as F,getActiveSpan as N}from"../../../../../core/build/esm/utils/spanUtils.js";import{addPerformanceInstrumentationHandler as U}from"../../../../../../sentry-internal/browser-utils/build/esm/metrics/instrument.js";import{extractNetworkProtocol as C}from"../../../../../../sentry-internal/browser-utils/build/esm/metrics/utils.js";import{browserPerformanceTimeOrigin as E}from"../../../../../core/build/esm/utils-hoist/time.js";import{hasSpansEnabled as R}from"../../../../../core/build/esm/utils/hasSpansEnabled.js";import{setHttpStatus as v}from"../../../../../core/build/esm/tracing/spanstatus.js";import{startInactiveSpan as L}from"../../../../../core/build/esm/tracing/trace.js";import{SEMANTIC_ATTRIBUTE_SENTRY_OP as X,SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN as W}from"../../../../../core/build/esm/semanticAttributes.js";import{SentryNonRecordingSpan as M}from"../../../../../core/build/esm/tracing/sentryNonRecordingSpan.js";import{getClient as Y}from"../../../../../core/build/esm/currentScopes.js";import{getTraceData as B}from"../../../../../core/build/esm/utils/traceData.js";import{getLocationHref as $}from"../../../../../core/build/esm/utils-hoist/browser.js";import{stringMatchesSomePattern as g}from"../../../../../core/build/esm/utils-hoist/string.js";const y=new WeakMap,T=new Map,G={traceFetch:!0,traceXHR:!0,enableHTTPTimings:!0,trackFetchStreamPerformance:!1};function St(t,n){const{traceFetch:a,traceXHR:r,trackFetchStreamPerformance:o,shouldCreateSpanForRequest:p,enableHTTPTimings:i,tracePropagationTargets:_,onRequestSpanStart:m}={...G,...n},d=typeof p=="function"?p:e=>!0,f=e=>Q(e,_),l={};a&&(t.addEventProcessor(e=>(e.type==="transaction"&&e.spans&&e.spans.forEach(s=>{if(s.op==="http.client"){const c=T.get(s.span_id);c&&(s.timestamp=c/1e3,T.delete(s.span_id))}}),e)),o&&x(e=>{if(e.response){const s=y.get(e.response);s&&e.endTimestamp&&T.set(s,e.endTimestamp)}}),w(e=>{const s=P(e,d,f,l);if(e.response&&e.fetchData.__span&&y.set(e.response,e.fetchData.__span),s){const c=I(e.fetchData.url),h=c?q(c).host:void 0;s.setAttributes({"http.url":c,"server.address":h}),i&&H(s),m?.(s,{headers:e.headers})}})),r&&A(e=>{const s=V(e,d,f,l);if(s){i&&H(s);let c;try{c=new Headers(e.xhr.__sentry_xhr_v3__?.request_headers)}catch{}m?.(s,{headers:c})}})}function J(t){return t.entryType==="resource"&&"initiatorType"in t&&typeof t.nextHopProtocol=="string"&&(t.initiatorType==="fetch"||t.initiatorType==="xmlhttprequest")}function H(t){const{url:n}=F(t).data;if(!n||typeof n!="string")return;const a=U("resource",({entries:r})=>{r.forEach(o=>{J(o)&&o.name.endsWith(n)&&(K(o).forEach(i=>t.setAttribute(...i)),setTimeout(a))})})}function u(t=0){return((E()||performance.timeOrigin)+t)/1e3}function K(t){const{name:n,version:a}=C(t.nextHopProtocol),r=[];return r.push(["network.protocol.version",a],["network.protocol.name",n]),E()?[...r,["http.request.redirect_start",u(t.redirectStart)],["http.request.fetch_start",u(t.fetchStart)],["http.request.domain_lookup_start",u(t.domainLookupStart)],["http.request.domain_lookup_end",u(t.domainLookupEnd)],["http.request.connect_start",u(t.connectStart)],["http.request.secure_connection_start",u(t.secureConnectionStart)],["http.request.connection_end",u(t.connectEnd)],["http.request.request_start",u(t.requestStart)],["http.request.response_start",u(t.responseStart)],["http.request.response_end",u(t.responseEnd)]]:r}function Q(t,n){const a=$();if(a){let r,o;try{r=new URL(t,a),o=new URL(a).origin}catch{return!1}const p=r.origin===o;return n?g(r.toString(),n)||p&&g(r.pathname,n):p}else{const r=!!t.match(/^\/(?!\/)/);return n?g(t,n):r}}function V(t,n,a,r){const o=t.xhr,p=o?.[O];if(!o||o.__sentry_own_request__||!p)return;const{url:i,method:_}=p,m=R()&&n(i);if(t.endTimestamp&&m){const h=o.__sentry_xhr_span_id__;if(!h)return;const S=r[h];S&&p.status_code!==void 0&&(v(S,p.status_code),S.end(),delete r[h]);return}const d=I(i),f=d?q(d):q(i),l=k(i),e=!!N(),s=m&&e?L({name:`${_} ${l}`,attributes:{url:i,type:"xhr","http.method":_,"http.url":d,"server.address":f?.host,[W]:"auto.http.browser",[X]:"http.client",...f?.search&&{"http.query":f?.search},...f?.hash&&{"http.fragment":f?.hash}}}):new M;o.__sentry_xhr_span_id__=s.spanContext().spanId,r[o.__sentry_xhr_span_id__]=s,a(i)&&j(o,R()&&e?s:void 0);const c=Y();return c&&c.emit("beforeOutgoingRequestSpan",s,t),s}function j(t,n){const{"sentry-trace":a,baggage:r}=B({span:n});a&&z(t,a,r)}function z(t,n,a){const r=t.__sentry_xhr_v3__?.request_headers;if(!r?.["sentry-trace"])try{if(t.setRequestHeader("sentry-trace",n),a){const o=r?.baggage;(!o||!Z(o))&&t.setRequestHeader("baggage",a)}}catch{}}function Z(t){return t.split(",").some(n=>n.trim().startsWith("sentry-"))}function I(t){try{return new URL(t,b.location.origin).href}catch{return}}export{G as defaultRequestInstrumentationOptions,St as instrumentOutgoingRequests,Q as shouldAttachHeaders,V as xhrCallback};
//# sourceMappingURL=request.js.map
