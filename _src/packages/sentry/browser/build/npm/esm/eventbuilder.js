import{isErrorEvent as d,isDOMError as v,isDOMException as O,isError as h,isPlainObject as F,isEvent as p,isParameterizedString as M}from"../../../../core/build/esm/utils-hoist/is.js";import{addExceptionTypeValue as y,addExceptionMechanism as u}from"../../../../core/build/esm/utils-hoist/misc.js";import{getClient as $}from"../../../../core/build/esm/currentScopes.js";import{normalizeToSize as T}from"../../../../core/build/esm/utils-hoist/normalize.js";import{extractExceptionKeysForMessage as j}from"../../../../core/build/esm/utils-hoist/object.js";import{resolvedSyncPromise as E}from"../../../../core/build/esm/utils-hoist/syncpromise.js";function _(r,e){const n=l(r,e),s={type:z(e),value:P(e)};return n.length&&(s.stacktrace={frames:n}),s.type===void 0&&s.value===""&&(s.value="Unrecoverable error caught"),s}function A(r,e,n,s){const t=$()?.getOptions().normalizeDepth,o=I(e),a={__serialized__:T(e,t)};if(o)return{exception:{values:[_(r,o)]},extra:a};const c={exception:{values:[{type:p(e)?e.constructor.name:s?"UnhandledRejection":"Error",value:N(e,{isUnhandledRejection:s})}]},extra:a};if(n){const g=l(r,n);g.length&&(c.exception.values[0].stacktrace={frames:g})}return c}function f(r,e){return{exception:{values:[_(r,e)]}}}function l(r,e){const n=e.stacktrace||e.stack||"",s=D(e),i=S(e);try{return r(n,s,i)}catch{}return[]}const k=/Minified React error #\d+;/i;function D(r){return r&&k.test(r.message)?1:0}function S(r){return typeof r.framesToPop=="number"?r.framesToPop:0}function b(r){return typeof WebAssembly<"u"&&typeof WebAssembly.Exception<"u"?r instanceof WebAssembly.Exception:!1}function z(r){const e=r?.name;return!e&&b(r)?r.message&&Array.isArray(r.message)&&r.message.length==2?r.message[0]:"WebAssembly.Exception":e}function P(r){const e=r?.message;return b(r)?Array.isArray(r.message)&&r.message.length==2?r.message[1]:"wasm exception":e?e.error&&typeof e.error.message=="string"?e.error.message:e:"No error message"}function q(r,e,n,s){const i=n?.syntheticException||void 0,t=w(r,e,i,s);return u(t),t.level="error",n?.event_id&&(t.event_id=n.event_id),E(t)}function B(r,e,n="info",s,i){const t=s?.syntheticException||void 0,o=m(r,e,t,i);return o.level=n,s?.event_id&&(o.event_id=s.event_id),E(o)}function w(r,e,n,s,i){let t;if(d(e)&&e.error)return f(r,e.error);if(v(e)||O(e)){const o=e;if("stack"in e)t=f(r,e);else{const a=o.name||(v(o)?"DOMError":"DOMException"),c=o.message?`${a}: ${o.message}`:a;t=m(r,c,n,s),y(t,c)}return"code"in o&&(t.tags={...t.tags,"DOMException.code":`${o.code}`}),t}return h(e)?f(r,e):F(e)||p(e)?(t=A(r,e,n,i),u(t,{synthetic:!0}),t):(t=m(r,e,n,s),y(t,`${e}`),u(t,{synthetic:!0}),t)}function m(r,e,n,s){const i={};if(s&&n){const t=l(r,n);t.length&&(i.exception={values:[{value:e,stacktrace:{frames:t}}]}),u(i,{synthetic:!0})}if(M(e)){const{__sentry_template_string__:t,__sentry_template_values__:o}=e;return i.logentry={message:t,params:o},i}return i.message=e,i}function N(r,{isUnhandledRejection:e}){const n=j(r),s=e?"promise rejection":"exception";return d(r)?`Event \`ErrorEvent\` captured as ${s} with message \`${r.message}\``:p(r)?`Event \`${W(r)}\` (type=${r.type}) captured as ${s}`:`Object captured as ${s} with keys: ${n}`}function W(r){try{const e=Object.getPrototypeOf(r);return e?e.constructor.name:void 0}catch{}}function I(r){for(const e in r)if(Object.prototype.hasOwnProperty.call(r,e)){const n=r[e];if(n instanceof Error)return n}}export{q as eventFromException,B as eventFromMessage,w as eventFromUnknownInput,_ as exceptionFromError,P as extractMessage,z as extractType};
//# sourceMappingURL=eventbuilder.js.map
