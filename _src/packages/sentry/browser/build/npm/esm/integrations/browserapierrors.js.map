{"version":3,"file":"browserapierrors.js","sources":["../../../../../../../../node_modules/@sentry/browser/build/npm/esm/integrations/browserapierrors.js"],"sourcesContent":["import { defineIntegration, fill, getFunctionName, getOriginalFunction } from '@sentry/core';\nimport { WINDOW, wrap } from '../helpers.js';\n\nconst DEFAULT_EVENT_TARGET = [\n  'EventTarget',\n  'Window',\n  'Node',\n  'ApplicationCache',\n  'AudioTrackList',\n  'BroadcastChannel',\n  'ChannelMergerNode',\n  'CryptoOperation',\n  'EventSource',\n  'FileReader',\n  'HTMLUnknownElement',\n  'IDBDatabase',\n  'IDBRequest',\n  'IDBTransaction',\n  'KeyOperation',\n  'MediaController',\n  'MessagePort',\n  'ModalWindow',\n  'Notification',\n  'SVGElementInstance',\n  'Screen',\n  'SharedWorker',\n  'TextTrack',\n  'TextTrackCue',\n  'TextTrackList',\n  'WebSocket',\n  'WebSocketWorker',\n  'Worker',\n  'XMLHttpRequest',\n  'XMLHttpRequestEventTarget',\n  'XMLHttpRequestUpload',\n];\n\nconst INTEGRATION_NAME = 'BrowserApiErrors';\n\nconst _browserApiErrorsIntegration = ((options = {}) => {\n  const _options = {\n    XMLHttpRequest: true,\n    eventTarget: true,\n    requestAnimationFrame: true,\n    setInterval: true,\n    setTimeout: true,\n    ...options,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    // TODO: This currently only works for the first client this is setup\n    // We may want to adjust this to check for client etc.\n    setupOnce() {\n      if (_options.setTimeout) {\n        fill(WINDOW, 'setTimeout', _wrapTimeFunction);\n      }\n\n      if (_options.setInterval) {\n        fill(WINDOW, 'setInterval', _wrapTimeFunction);\n      }\n\n      if (_options.requestAnimationFrame) {\n        fill(WINDOW, 'requestAnimationFrame', _wrapRAF);\n      }\n\n      if (_options.XMLHttpRequest && 'XMLHttpRequest' in WINDOW) {\n        fill(XMLHttpRequest.prototype, 'send', _wrapXHR);\n      }\n\n      const eventTargetOption = _options.eventTarget;\n      if (eventTargetOption) {\n        const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n        eventTarget.forEach(_wrapEventTarget);\n      }\n    },\n  };\n}) ;\n\n/**\n * Wrap timer functions and event targets to catch errors and provide better meta data.\n */\nconst browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);\n\nfunction _wrapTimeFunction(original) {\n  return function ( ...args) {\n    const originalCallback = args[0];\n    args[0] = wrap(originalCallback, {\n      mechanism: {\n        data: { function: getFunctionName(original) },\n        handled: false,\n        type: 'instrument',\n      },\n    });\n    return original.apply(this, args);\n  };\n}\n\nfunction _wrapRAF(original) {\n  return function ( callback) {\n    return original.apply(this, [\n      wrap(callback, {\n        mechanism: {\n          data: {\n            function: 'requestAnimationFrame',\n            handler: getFunctionName(original),\n          },\n          handled: false,\n          type: 'instrument',\n        },\n      }),\n    ]);\n  };\n}\n\nfunction _wrapXHR(originalSend) {\n  return function ( ...args) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const xhr = this;\n    const xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n\n    xmlHttpRequestProps.forEach(prop => {\n      if (prop in xhr && typeof xhr[prop] === 'function') {\n        fill(xhr, prop, function (original) {\n          const wrapOptions = {\n            mechanism: {\n              data: {\n                function: prop,\n                handler: getFunctionName(original),\n              },\n              handled: false,\n              type: 'instrument',\n            },\n          };\n\n          // If Instrument integration has been called before BrowserApiErrors, get the name of original function\n          const originalFunction = getOriginalFunction(original);\n          if (originalFunction) {\n            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);\n          }\n\n          // Otherwise wrap directly\n          return wrap(original, wrapOptions);\n        });\n      }\n    });\n\n    return originalSend.apply(this, args);\n  };\n}\n\nfunction _wrapEventTarget(target) {\n  const globalObject = WINDOW ;\n  const proto = globalObject[target]?.prototype;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (!proto?.hasOwnProperty?.('addEventListener')) {\n    return;\n  }\n\n  fill(proto, 'addEventListener', function (original)\n\n {\n    return function ( eventName, fn, options) {\n      try {\n        if (isEventListenerObject(fn)) {\n          // ESlint disable explanation:\n          //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would\n          //  introduce a bug here, because bind returns a new function that doesn't have our\n          //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.\n          //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          fn.handleEvent = wrap(fn.handleEvent, {\n            mechanism: {\n              data: {\n                function: 'handleEvent',\n                handler: getFunctionName(fn),\n                target,\n              },\n              handled: false,\n              type: 'instrument',\n            },\n          });\n        }\n      } catch {\n        // can sometimes get 'Permission denied to access property \"handle Event'\n      }\n\n      return original.apply(this, [\n        eventName,\n        wrap(fn, {\n          mechanism: {\n            data: {\n              function: 'addEventListener',\n              handler: getFunctionName(fn),\n              target,\n            },\n            handled: false,\n            type: 'instrument',\n          },\n        }),\n        options,\n      ]);\n    };\n  });\n\n  fill(proto, 'removeEventListener', function (originalRemoveEventListener)\n\n {\n    return function ( eventName, fn, options) {\n      /**\n       * There are 2 possible scenarios here:\n       *\n       * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n       * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n       * as a pass-through, and call original `removeEventListener` with it.\n       *\n       * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n       * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n       * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n       * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n       * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n       *\n       * When someone adds a handler prior to initialization, and then do it again, but after,\n       * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n       * to get rid of the initial handler and it'd stick there forever.\n       */\n      try {\n        const originalEventHandler = (fn ).__sentry_wrapped__;\n        if (originalEventHandler) {\n          originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n        }\n      } catch (e) {\n        // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n      }\n      return originalRemoveEventListener.call(this, eventName, fn, options);\n    };\n  });\n}\n\nfunction isEventListenerObject(obj) {\n  return typeof (obj ).handleEvent === 'function';\n}\n\nexport { browserApiErrorsIntegration };\n//# sourceMappingURL=browserapierrors.js.map\n"],"names":["DEFAULT_EVENT_TARGET","INTEGRATION_NAME","_browserApiErrorsIntegration","options","_options","fill","WINDOW","_wrapTimeFunction","_wrapRAF","_wrapXHR","eventTargetOption","_wrapEventTarget","browserApiErrorsIntegration","defineIntegration","original","args","originalCallback","wrap","getFunctionName","callback","originalSend","xhr","prop","wrapOptions","originalFunction","getOriginalFunction","target","proto","eventName","fn","isEventListenerObject","originalRemoveEventListener","originalEventHandler","obj"],"mappings":"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","x_google_ignoreList":[0]}