{"version":3,"file":"integration.js","sources":["../../../../../../node_modules/@sentry/core/build/esm/integration.js"],"sourcesContent":["import { getClient } from './currentScopes.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { logger } from './utils-hoist/logger.js';\n\nconst installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preserve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  const integrationsByName = {};\n\n  integrations.forEach((currentInstance) => {\n    const { name } = currentInstance;\n\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach((integration) => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations;\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    const resolvedUserIntegrations = userIntegrations(defaultIntegrations);\n    integrations = Array.isArray(resolvedUserIntegrations) ? resolvedUserIntegrations : [resolvedUserIntegrations];\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  return filterDuplicates(integrations);\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(client, integrations) {\n  const integrationIndex = {};\n\n  integrations.forEach((integration) => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(client, integration, integrationIndex);\n    }\n  });\n\n  return integrationIndex;\n}\n\n/**\n * Execute the `afterAllSetup` hooks of the given integrations.\n */\nfunction afterSetupIntegrations(client, integrations) {\n  for (const integration of integrations) {\n    // guard against empty provided integrations\n    if (integration?.afterAllSetup) {\n      integration.afterAllSetup(client);\n    }\n  }\n}\n\n/** Setup a single integration.  */\nfunction setupIntegration(client, integration, integrationIndex) {\n  if (integrationIndex[integration.name]) {\n    DEBUG_BUILD && logger.log(`Integration skipped because it was already installed: ${integration.name}`);\n    return;\n  }\n  integrationIndex[integration.name] = integration;\n\n  // `setupOnce` is only called the first time\n  if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === 'function') {\n    integration.setupOnce();\n    installedIntegrations.push(integration.name);\n  }\n\n  // `setup` is run for each client\n  if (integration.setup && typeof integration.setup === 'function') {\n    integration.setup(client);\n  }\n\n  if (typeof integration.preprocessEvent === 'function') {\n    const callback = integration.preprocessEvent.bind(integration) ;\n    client.on('preprocessEvent', (event, hint) => callback(event, hint, client));\n  }\n\n  if (typeof integration.processEvent === 'function') {\n    const callback = integration.processEvent.bind(integration) ;\n\n    const processor = Object.assign((event, hint) => callback(event, hint, client), {\n      id: integration.name,\n    });\n\n    client.addEventProcessor(processor);\n  }\n\n  DEBUG_BUILD && logger.log(`Integration installed: ${integration.name}`);\n}\n\n/** Add an integration to the current scope's client. */\nfunction addIntegration(integration) {\n  const client = getClient();\n\n  if (!client) {\n    DEBUG_BUILD && logger.warn(`Cannot add integration \"${integration.name}\" because no SDK Client is available.`);\n    return;\n  }\n\n  client.addIntegration(integration);\n}\n\n/**\n * Define an integration function that can be used to create an integration instance.\n * Note that this by design hides the implementation details of the integration, as they are considered internal.\n */\nfunction defineIntegration(fn) {\n  return fn;\n}\n\nexport { addIntegration, afterSetupIntegrations, defineIntegration, getIntegrationsToSetup, installedIntegrations, setupIntegration, setupIntegrations };\n//# sourceMappingURL=integration.js.map\n"],"names":["installedIntegrations","filterDuplicates","integrations","integrationsByName","currentInstance","name","existingInstance","getIntegrationsToSetup","options","defaultIntegrations","userIntegrations","integration","resolvedUserIntegrations","setupIntegrations","client","integrationIndex","setupIntegration","afterSetupIntegrations","DEBUG_BUILD","logger","callback","event","hint","processor","defineIntegration","fn"],"mappings":"gGAIK,MAACA,EAAwB,CAAA,EAU9B,SAASC,EAAiBC,EAAc,CACtC,MAAMC,EAAqB,CAAE,EAE7B,OAAAD,EAAa,QAASE,GAAoB,CACxC,KAAM,CAAE,KAAAC,CAAI,EAAKD,EAEXE,EAAmBH,EAAmBE,CAAI,EAI5CC,GAAoB,CAACA,EAAiB,mBAAqBF,EAAgB,oBAI/ED,EAAmBE,CAAI,EAAID,EAC/B,CAAG,EAEM,OAAO,OAAOD,CAAkB,CACzC,CAGA,SAASI,EAAuBC,EAAS,CACvC,MAAMC,EAAsBD,EAAQ,qBAAuB,CAAE,EACvDE,EAAmBF,EAAQ,aAGjCC,EAAoB,QAASE,GAAgB,CAC3CA,EAAY,kBAAoB,EACpC,CAAG,EAED,IAAIT,EAEJ,GAAI,MAAM,QAAQQ,CAAgB,EAChCR,EAAe,CAAC,GAAGO,EAAqB,GAAGC,CAAgB,UAClD,OAAOA,GAAqB,WAAY,CACjD,MAAME,EAA2BF,EAAiBD,CAAmB,EACrEP,EAAe,MAAM,QAAQU,CAAwB,EAAIA,EAA2B,CAACA,CAAwB,CACjH,MACIV,EAAeO,EAGjB,OAAOR,EAAiBC,CAAY,CACtC,CAQA,SAASW,EAAkBC,EAAQZ,EAAc,CAC/C,MAAMa,EAAmB,CAAE,EAE3B,OAAAb,EAAa,QAASS,GAAgB,CAEhCA,GACFK,EAAiBF,EAAQH,EAAaI,CAAgB,CAE5D,CAAG,EAEMA,CACT,CAKA,SAASE,EAAuBH,EAAQZ,EAAc,CACpD,UAAWS,KAAeT,EAEpBS,GAAa,eACfA,EAAY,cAAcG,CAAM,CAGtC,CAGA,SAASE,EAAiBF,EAAQH,EAAaI,EAAkB,CAC/D,GAAIA,EAAiBJ,EAAY,IAAI,EAAG,CACtCO,GAAeC,EAAO,IAAI,yDAAyDR,EAAY,IAAI,EAAE,EACrG,MACJ,CAcE,GAbAI,EAAiBJ,EAAY,IAAI,EAAIA,EAGjCX,EAAsB,QAAQW,EAAY,IAAI,IAAM,IAAM,OAAOA,EAAY,WAAc,aAC7FA,EAAY,UAAW,EACvBX,EAAsB,KAAKW,EAAY,IAAI,GAIzCA,EAAY,OAAS,OAAOA,EAAY,OAAU,YACpDA,EAAY,MAAMG,CAAM,EAGtB,OAAOH,EAAY,iBAAoB,WAAY,CACrD,MAAMS,EAAWT,EAAY,gBAAgB,KAAKA,CAAW,EAC7DG,EAAO,GAAG,kBAAmB,CAACO,EAAOC,IAASF,EAASC,EAAOC,EAAMR,CAAM,CAAC,CAC/E,CAEE,GAAI,OAAOH,EAAY,cAAiB,WAAY,CAClD,MAAMS,EAAWT,EAAY,aAAa,KAAKA,CAAW,EAEpDY,EAAY,OAAO,OAAO,CAACF,EAAOC,IAASF,EAASC,EAAOC,EAAMR,CAAM,EAAG,CAC9E,GAAIH,EAAY,IACtB,CAAK,EAEDG,EAAO,kBAAkBS,CAAS,CACtC,CAEEL,GAAeC,EAAO,IAAI,0BAA0BR,EAAY,IAAI,EAAE,CACxE,CAkBA,SAASa,EAAkBC,EAAI,CAC7B,OAAOA,CACT","x_google_ignoreList":[0]}