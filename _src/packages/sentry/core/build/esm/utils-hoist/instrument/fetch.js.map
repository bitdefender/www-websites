{"version":3,"file":"fetch.js","sources":["../../../../../../../../node_modules/@sentry/core/build/esm/utils-hoist/instrument/fetch.js"],"sourcesContent":["import { isError, isRequest } from '../is.js';\nimport { fill, addNonEnumerableProperty } from '../object.js';\nimport { supportsNativeFetch } from '../supports.js';\nimport { timestampInSeconds } from '../time.js';\nimport { GLOBAL_OBJ } from '../worldwide.js';\nimport { addHandler, maybeInstrument, triggerHandlers } from './handlers.js';\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addFetchInstrumentationHandler(\n  handler,\n  skipNativeFetchCheck,\n) {\n  const type = 'fetch';\n  addHandler(type, handler);\n  maybeInstrument(type, () => instrumentFetch(undefined, skipNativeFetchCheck));\n}\n\n/**\n * Add an instrumentation handler for long-lived fetch requests, like consuming server-sent events (SSE) via fetch.\n * The handler will resolve the request body and emit the actual `endTimestamp`, so that the\n * span can be updated accordingly.\n *\n * Only used internally\n * @hidden\n */\nfunction addFetchEndInstrumentationHandler(handler) {\n  const type = 'fetch-body-resolved';\n  addHandler(type, handler);\n  maybeInstrument(type, () => instrumentFetch(streamHandler));\n}\n\nfunction instrumentFetch(onFetchResolved, skipNativeFetchCheck = false) {\n  if (skipNativeFetchCheck && !supportsNativeFetch()) {\n    return;\n  }\n\n  fill(GLOBAL_OBJ, 'fetch', function (originalFetch) {\n    return function (...args) {\n      // We capture the error right here and not in the Promise error callback because Safari (and probably other\n      // browsers too) will wipe the stack trace up to this point, only leaving us with this file which is useless.\n\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n      //       it means the error, that was caused by your fetch call did not\n      //       have a stack trace, so the SDK backfilled the stack trace so\n      //       you can see which fetch call failed.\n      const virtualError = new Error();\n\n      const { method, url } = parseFetchArgs(args);\n      const handlerData = {\n        args,\n        fetchData: {\n          method,\n          url,\n        },\n        startTimestamp: timestampInSeconds() * 1000,\n        // // Adding the error to be able to fingerprint the failed fetch event in HttpClient instrumentation\n        virtualError,\n        headers: getHeadersFromFetchArgs(args),\n      };\n\n      // if there is no callback, fetch is instrumented directly\n      if (!onFetchResolved) {\n        triggerHandlers('fetch', {\n          ...handlerData,\n        });\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(GLOBAL_OBJ, args).then(\n        async (response) => {\n          if (onFetchResolved) {\n            onFetchResolved(response);\n          } else {\n            triggerHandlers('fetch', {\n              ...handlerData,\n              endTimestamp: timestampInSeconds() * 1000,\n              response,\n            });\n          }\n\n          return response;\n        },\n        (error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: timestampInSeconds() * 1000,\n            error,\n          });\n\n          if (isError(error) && error.stack === undefined) {\n            // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n            //       it means the error, that was caused by your fetch call did not\n            //       have a stack trace, so the SDK backfilled the stack trace so\n            //       you can see which fetch call failed.\n            error.stack = virtualError.stack;\n            addNonEnumerableProperty(error, 'framesToPop', 1);\n          }\n\n          // We enhance the not-so-helpful \"Failed to fetch\" error messages with the host\n          // Possible messages we handle here:\n          // * \"Failed to fetch\" (chromium)\n          // * \"Load failed\" (webkit)\n          // * \"NetworkError when attempting to fetch resource.\" (firefox)\n          if (\n            error instanceof TypeError &&\n            (error.message === 'Failed to fetch' ||\n              error.message === 'Load failed' ||\n              error.message === 'NetworkError when attempting to fetch resource.')\n          ) {\n            try {\n              const url = new URL(handlerData.fetchData.url);\n              error.message = `${error.message} (${url.host})`;\n            } catch {\n              // ignore it if errors happen here\n            }\n          }\n\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\nasync function resolveResponse(res, onFinishedResolving) {\n  if (res?.body) {\n    const body = res.body;\n    const responseReader = body.getReader();\n\n    // Define a maximum duration after which we just cancel\n    const maxFetchDurationTimeout = setTimeout(\n      () => {\n        body.cancel().then(null, () => {\n          // noop\n        });\n      },\n      90 * 1000, // 90s\n    );\n\n    let readingActive = true;\n    while (readingActive) {\n      let chunkTimeout;\n      try {\n        // abort reading if read op takes more than 5s\n        chunkTimeout = setTimeout(() => {\n          body.cancel().then(null, () => {\n            // noop on error\n          });\n        }, 5000);\n\n        // This .read() call will reject/throw when we abort due to timeouts through `body.cancel()`\n        const { done } = await responseReader.read();\n\n        clearTimeout(chunkTimeout);\n\n        if (done) {\n          onFinishedResolving();\n          readingActive = false;\n        }\n      } catch (error) {\n        readingActive = false;\n      } finally {\n        clearTimeout(chunkTimeout);\n      }\n    }\n\n    clearTimeout(maxFetchDurationTimeout);\n\n    responseReader.releaseLock();\n    body.cancel().then(null, () => {\n      // noop on error\n    });\n  }\n}\n\nfunction streamHandler(response) {\n  // clone response for awaiting stream\n  let clonedResponseForResolving;\n  try {\n    clonedResponseForResolving = response.clone();\n  } catch {\n    return;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  resolveResponse(clonedResponseForResolving, () => {\n    triggerHandlers('fetch-body-resolved', {\n      endTimestamp: timestampInSeconds() * 1000,\n      response,\n    });\n  });\n}\n\nfunction hasProp(obj, prop) {\n  return !!obj && typeof obj === 'object' && !!(obj )[prop];\n}\n\nfunction getUrlFromResource(resource) {\n  if (typeof resource === 'string') {\n    return resource;\n  }\n\n  if (!resource) {\n    return '';\n  }\n\n  if (hasProp(resource, 'url')) {\n    return resource.url;\n  }\n\n  if (resource.toString) {\n    return resource.toString();\n  }\n\n  return '';\n}\n\n/**\n * Parses the fetch arguments to find the used Http method and the url of the request.\n * Exported for tests only.\n */\nfunction parseFetchArgs(fetchArgs) {\n  if (fetchArgs.length === 0) {\n    return { method: 'GET', url: '' };\n  }\n\n  if (fetchArgs.length === 2) {\n    const [url, options] = fetchArgs ;\n\n    return {\n      url: getUrlFromResource(url),\n      method: hasProp(options, 'method') ? String(options.method).toUpperCase() : 'GET',\n    };\n  }\n\n  const arg = fetchArgs[0];\n  return {\n    url: getUrlFromResource(arg ),\n    method: hasProp(arg, 'method') ? String(arg.method).toUpperCase() : 'GET',\n  };\n}\n\nfunction getHeadersFromFetchArgs(fetchArgs) {\n  const [requestArgument, optionsArgument] = fetchArgs;\n\n  try {\n    if (\n      typeof optionsArgument === 'object' &&\n      optionsArgument !== null &&\n      'headers' in optionsArgument &&\n      optionsArgument.headers\n    ) {\n      return new Headers(optionsArgument.headers );\n    }\n\n    if (isRequest(requestArgument)) {\n      return new Headers(requestArgument.headers);\n    }\n  } catch {\n    // noop\n  }\n\n  return;\n}\n\nexport { addFetchEndInstrumentationHandler, addFetchInstrumentationHandler, parseFetchArgs };\n//# sourceMappingURL=fetch.js.map\n"],"names":["addFetchInstrumentationHandler","handler","skipNativeFetchCheck","type","addHandler","maybeInstrument","instrumentFetch","addFetchEndInstrumentationHandler","streamHandler","onFetchResolved","supportsNativeFetch","fill","GLOBAL_OBJ","originalFetch","args","virtualError","method","url","parseFetchArgs","handlerData","timestampInSeconds","getHeadersFromFetchArgs","triggerHandlers","response","error","isError","addNonEnumerableProperty","resolveResponse","res","onFinishedResolving","body","responseReader","maxFetchDurationTimeout","readingActive","chunkTimeout","done","clonedResponseForResolving","hasProp","obj","prop","getUrlFromResource","resource","fetchArgs","options","arg","requestArgument","optionsArgument","isRequest"],"mappings":"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","x_google_ignoreList":[0]}