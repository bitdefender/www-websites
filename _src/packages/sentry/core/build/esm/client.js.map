{"version":3,"file":"client.js","sources":["../../../../../../node_modules/@sentry/core/build/esm/client.js"],"sourcesContent":["import { getEnvelopeEndpointWithUrlEncodedAuth } from './api.js';\nimport { DEFAULT_ENVIRONMENT } from './constants.js';\nimport { getTraceContextFromScope, getCurrentScope, getIsolationScope } from './currentScopes.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope.js';\nimport { setupIntegration, afterSetupIntegrations, setupIntegrations } from './integration.js';\nimport { updateSession } from './session.js';\nimport { getDynamicSamplingContextFromScope, getDynamicSamplingContextFromSpan } from './tracing/dynamicSamplingContext.js';\nimport { getPossibleEventMessages } from './utils/eventUtils.js';\nimport { merge } from './utils/merge.js';\nimport { parseSampleRate } from './utils/parseSampleRate.js';\nimport { prepareEvent } from './utils/prepareEvent.js';\nimport { _getSpanForScope } from './utils/spanOnScope.js';\nimport { showSpanDropWarning, spanToTraceContext } from './utils/spanUtils.js';\nimport { convertTransactionEventToSpanJson, convertSpanJsonToTransactionEvent } from './utils/transactionEvent.js';\nimport { createClientReportEnvelope } from './utils-hoist/clientreport.js';\nimport { makeDsn, dsnToString } from './utils-hoist/dsn.js';\nimport { addItemToEnvelope, createAttachmentEnvelopeItem } from './utils-hoist/envelope.js';\nimport { isPrimitive, isParameterizedString, isThenable, isPlainObject } from './utils-hoist/is.js';\nimport { logger } from './utils-hoist/logger.js';\nimport { uuid4, checkOrSetAlreadyCaught } from './utils-hoist/misc.js';\nimport { resolvedSyncPromise, SyncPromise, rejectedSyncPromise } from './utils-hoist/syncpromise.js';\n\n/* eslint-disable max-lines */\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\nconst MISSING_RELEASE_FOR_SESSION_ERROR = 'Discarded session because of missing or non-string release';\n\nconst INTERNAL_ERROR_SYMBOL = Symbol.for('SentryInternalError');\nconst DO_NOT_SEND_EVENT_SYMBOL = Symbol.for('SentryDoNotSendEventError');\n\nfunction _makeInternalError(message) {\n  return {\n    message,\n    [INTERNAL_ERROR_SYMBOL]: true,\n  };\n}\n\nfunction _makeDoNotSendEventError(message) {\n  return {\n    message,\n    [DO_NOT_SEND_EVENT_SYMBOL]: true,\n  };\n}\n\nfunction _isInternalError(error) {\n  return !!error && typeof error === 'object' && INTERNAL_ERROR_SYMBOL in error;\n}\n\nfunction _isDoNotSendEventError(error) {\n  return !!error && typeof error === 'object' && DO_NOT_SEND_EVENT_SYMBOL in error;\n}\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link Client._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends Client<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nclass Client {\n  /** Options passed to the SDK. */\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n\n  /** Array of set up integrations. */\n\n  /** Number of calls being processed */\n\n  /** Holds flushable  */\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n   constructor(options) {\n    this._options = options;\n    this._integrations = {};\n    this._numProcessing = 0;\n    this._outcomes = {};\n    this._hooks = {};\n    this._eventProcessors = [];\n\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    } else {\n      DEBUG_BUILD && logger.warn('No DSN provided, client will not send events.');\n    }\n\n    if (this._dsn) {\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(\n        this._dsn,\n        options.tunnel,\n        options._metadata ? options._metadata.sdk : undefined,\n      );\n      this._transport = options.transport({\n        tunnel: this._options.tunnel,\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    }\n  }\n\n  /**\n   * Captures an exception event and sends it to Sentry.\n   *\n   * Unlike `captureException` exported from every SDK, this method requires that you pass it the current scope.\n   */\n   captureException(exception, hint, scope) {\n    const eventId = uuid4();\n\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint,\n    };\n\n    this._process(\n      this.eventFromException(exception, hintWithEventId).then(event =>\n        this._captureEvent(event, hintWithEventId, scope),\n      ),\n    );\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a message event and sends it to Sentry.\n   *\n   * Unlike `captureMessage` exported from every SDK, this method requires that you pass it the current scope.\n   */\n   captureMessage(\n    message,\n    level,\n    hint,\n    currentScope,\n  ) {\n    const hintWithEventId = {\n      event_id: uuid4(),\n      ...hint,\n    };\n\n    const eventMessage = isParameterizedString(message) ? message : String(message);\n\n    const promisedEvent = isPrimitive(message)\n      ? this.eventFromMessage(eventMessage, level, hintWithEventId)\n      : this.eventFromException(message, hintWithEventId);\n\n    this._process(promisedEvent.then(event => this._captureEvent(event, hintWithEventId, currentScope)));\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a manually created event and sends it to Sentry.\n   *\n   * Unlike `captureEvent` exported from every SDK, this method requires that you pass it the current scope.\n   */\n   captureEvent(event, hint, currentScope) {\n    const eventId = uuid4();\n\n    // ensure we haven't captured this very object before\n    if (hint?.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint,\n    };\n\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;\n    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;\n\n    this._process(\n      this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope, capturedSpanIsolationScope),\n    );\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a session.\n   */\n   captureSession(session) {\n    this.sendSession(session);\n    // After sending, we set init false to indicate it's not the first occurrence\n    updateSession(session, { init: false });\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry. This method is not available on all clients.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   * @param scope An optional scope containing event metadata.\n   * @returns A string representing the id of the check in.\n   */\n\n  /**\n   * Get the current Dsn.\n   */\n   getDsn() {\n    return this._dsn;\n  }\n\n  /**\n   * Get the current options.\n   */\n   getOptions() {\n    return this._options;\n  }\n\n  /**\n   * Get the SDK metadata.\n   * @see SdkMetadata\n   */\n   getSdkMetadata() {\n    return this._options._metadata;\n  }\n\n  /**\n   * Returns the transport that is used by the client.\n   * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.\n   */\n   getTransport() {\n    return this._transport;\n  }\n\n  /**\n   * Wait for all events to be sent or the timeout to expire, whichever comes first.\n   *\n   * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will\n   *   cause the client to wait until all events are sent before resolving the promise.\n   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are\n   * still events in the queue when the timeout is reached.\n   */\n   flush(timeout) {\n    const transport = this._transport;\n    if (transport) {\n      this.emit('flush');\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.\n   *\n   * @param {number} timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause\n   *   the client to wait until all events are sent before disabling itself.\n   * @returns {Promise<boolean>} A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if\n   * it doesn't.\n   */\n   close(timeout) {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      this.emit('close');\n      return result;\n    });\n  }\n\n  /**\n   * Get all installed event processors.\n   */\n   getEventProcessors() {\n    return this._eventProcessors;\n  }\n\n  /**\n   * Adds an event processor that applies to any event processed by this client.\n   */\n   addEventProcessor(eventProcessor) {\n    this._eventProcessors.push(eventProcessor);\n  }\n\n  /**\n   * Initialize this client.\n   * Call this after the client was set on a scope.\n   */\n   init() {\n    if (\n      this._isEnabled() ||\n      // Force integrations to be setup even if no DSN was set when we have\n      // Spotlight enabled. This is particularly important for browser as we\n      // don't support the `spotlight` option there and rely on the users\n      // adding the `spotlightBrowserIntegration()` to their integrations which\n      // wouldn't get initialized with the check below when there's no DSN set.\n      this._options.integrations.some(({ name }) => name.startsWith('Spotlight'))\n    ) {\n      this._setupIntegrations();\n    }\n  }\n\n  /**\n   * Gets an installed integration by its name.\n   *\n   * @returns {Integration|undefined} The installed integration or `undefined` if no integration with that `name` was installed.\n   */\n   getIntegrationByName(integrationName) {\n    return this._integrations[integrationName] ;\n  }\n\n  /**\n   * Add an integration to the client.\n   * This can be used to e.g. lazy load integrations.\n   * In most cases, this should not be necessary,\n   * and you're better off just passing the integrations via `integrations: []` at initialization time.\n   * However, if you find the need to conditionally load & add an integration, you can use `addIntegration` to do so.\n   */\n   addIntegration(integration) {\n    const isAlreadyInstalled = this._integrations[integration.name];\n\n    // This hook takes care of only installing if not already installed\n    setupIntegration(this, integration, this._integrations);\n    // Here we need to check manually to make sure to not run this multiple times\n    if (!isAlreadyInstalled) {\n      afterSetupIntegrations(this, [integration]);\n    }\n  }\n\n  /**\n   * Send a fully prepared event to Sentry.\n   */\n   sendEvent(event, hint = {}) {\n    this.emit('beforeSendEvent', event, hint);\n\n    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n    for (const attachment of hint.attachments || []) {\n      env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment));\n    }\n\n    const promise = this.sendEnvelope(env);\n    if (promise) {\n      promise.then(sendResponse => this.emit('afterSendEvent', event, sendResponse), null);\n    }\n  }\n\n  /**\n   * Send a session or session aggregrates to Sentry.\n   */\n   sendSession(session) {\n    // Backfill release and environment on session\n    const { release: clientReleaseOption, environment: clientEnvironmentOption = DEFAULT_ENVIRONMENT } = this._options;\n    if ('aggregates' in session) {\n      const sessionAttrs = session.attrs || {};\n      if (!sessionAttrs.release && !clientReleaseOption) {\n        DEBUG_BUILD && logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      sessionAttrs.release = sessionAttrs.release || clientReleaseOption;\n      sessionAttrs.environment = sessionAttrs.environment || clientEnvironmentOption;\n      session.attrs = sessionAttrs;\n    } else {\n      if (!session.release && !clientReleaseOption) {\n        DEBUG_BUILD && logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      session.release = session.release || clientReleaseOption;\n      session.environment = session.environment || clientEnvironmentOption;\n    }\n\n    this.emit('beforeSendSession', session);\n\n    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(env);\n  }\n\n  /**\n   * Record on the client that an event got dropped (ie, an event that will not be sent to Sentry).\n   */\n   recordDroppedEvent(reason, category, count = 1) {\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      DEBUG_BUILD && logger.log(`Recording outcome: \"${key}\"${count > 1 ? ` (${count} times)` : ''}`);\n      this._outcomes[key] = (this._outcomes[key] || 0) + count;\n    }\n  }\n\n  /* eslint-disable @typescript-eslint/unified-signatures */\n  /**\n   * Register a callback for whenever a span is started.\n   * Receives the span as argument.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n\n  /**\n   * Register a hook on this client.\n   */\n   on(hook, callback) {\n    const hooks = (this._hooks[hook] = this._hooks[hook] || []);\n\n    // @ts-expect-error We assume the types are correct\n    hooks.push(callback);\n\n    // This function returns a callback execution handler that, when invoked,\n    // deregisters a callback. This is crucial for managing instances where callbacks\n    // need to be unregistered to prevent self-referencing in callback closures,\n    // ensuring proper garbage collection.\n    return () => {\n      // @ts-expect-error We assume the types are correct\n      const cbIndex = hooks.indexOf(callback);\n      if (cbIndex > -1) {\n        hooks.splice(cbIndex, 1);\n      }\n    };\n  }\n\n  /** Fire a hook whenever a span starts. */\n\n  /**\n   * Emit a hook that was previously registered via `on()`.\n   */\n   emit(hook, ...rest) {\n    const callbacks = this._hooks[hook];\n    if (callbacks) {\n      callbacks.forEach(callback => callback(...rest));\n    }\n  }\n\n  /**\n   * Send an envelope to Sentry.\n   */\n   sendEnvelope(envelope) {\n    this.emit('beforeEnvelope', envelope);\n\n    if (this._isEnabled() && this._transport) {\n      return this._transport.send(envelope).then(null, reason => {\n        DEBUG_BUILD && logger.error('Error while sending envelope:', reason);\n        return reason;\n      });\n    }\n\n    DEBUG_BUILD && logger.error('Transport disabled');\n\n    return resolvedSyncPromise({});\n  }\n\n  /* eslint-enable @typescript-eslint/unified-signatures */\n\n  /** Setup integrations for this client. */\n   _setupIntegrations() {\n    const { integrations } = this._options;\n    this._integrations = setupIntegrations(this, integrations);\n    afterSetupIntegrations(this, integrations);\n  }\n\n  /** Updates existing session based on the provided event */\n   _updateSessionFromEvent(session, event) {\n    let crashed = event.level === 'fatal';\n    let errored = false;\n    const exceptions = event.exception?.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism?.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n   _isClientDoneProcessing(timeout) {\n    return new SyncPromise(resolve => {\n      let ticked = 0;\n      const tick = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a transport is present. */\n   _isEnabled() {\n    return this.getOptions().enabled !== false && this._transport !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n   _prepareEvent(\n    event,\n    hint,\n    currentScope,\n    isolationScope,\n  ) {\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations?.length) {\n      hint.integrations = integrations;\n    }\n\n    this.emit('preprocessEvent', event, hint);\n\n    if (!event.type) {\n      isolationScope.setLastEventId(event.event_id || hint.event_id);\n    }\n\n    return prepareEvent(options, event, hint, currentScope, this, isolationScope).then(evt => {\n      if (evt === null) {\n        return evt;\n      }\n\n      this.emit('postprocessEvent', evt, hint);\n\n      evt.contexts = {\n        trace: getTraceContextFromScope(currentScope),\n        ...evt.contexts,\n      };\n\n      const dynamicSamplingContext = getDynamicSamplingContextFromScope(this, currentScope);\n\n      evt.sdkProcessingMetadata = {\n        dynamicSamplingContext,\n        ...evt.sdkProcessingMetadata,\n      };\n\n      return evt;\n    });\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n   _captureEvent(\n    event,\n    hint = {},\n    currentScope = getCurrentScope(),\n    isolationScope = getIsolationScope(),\n  ) {\n    if (DEBUG_BUILD && isErrorEvent(event)) {\n      logger.log(`Captured error event \\`${getPossibleEventMessages(event)[0] || '<unknown>'}\\``);\n    }\n\n    return this._processEvent(event, hint, currentScope, isolationScope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if (DEBUG_BUILD) {\n          if (_isDoNotSendEventError(reason)) {\n            logger.log(reason.message);\n          } else if (_isInternalError(reason)) {\n            logger.warn(reason.message);\n          } else {\n            logger.warn(reason);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n   _processEvent(\n    event,\n    hint,\n    currentScope,\n    isolationScope,\n  ) {\n    const options = this.getOptions();\n    const { sampleRate } = options;\n\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    const parsedSampleRate = typeof sampleRate === 'undefined' ? undefined : parseSampleRate(sampleRate);\n    if (isError && typeof parsedSampleRate === 'number' && Math.random() > parsedSampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error');\n      return rejectedSyncPromise(\n        _makeDoNotSendEventError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n        ),\n      );\n    }\n\n    const dataCategory = (eventType === 'replay_event' ? 'replay' : eventType) ;\n\n    return this._prepareEvent(event, hint, currentScope, isolationScope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', dataCategory);\n          throw _makeDoNotSendEventError('An event processor returned `null`, will not send event.');\n        }\n\n        const isInternalException = hint.data && (hint.data ).__sentry__ === true;\n        if (isInternalException) {\n          return prepared;\n        }\n\n        const result = processBeforeSend(this, options, prepared, hint);\n        return _validateBeforeSendResult(result, beforeSendLabel);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', dataCategory);\n          if (isTransaction) {\n            const spans = event.spans || [];\n            // the transaction itself counts as one span, plus all the child spans that are added\n            const spanCount = 1 + spans.length;\n            this.recordDroppedEvent('before_send', 'span', spanCount);\n          }\n          throw _makeDoNotSendEventError(`${beforeSendLabel} returned \\`null\\`, will not send event.`);\n        }\n\n        const session = currentScope.getSession() || isolationScope.getSession();\n        if (isError && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        if (isTransaction) {\n          const spanCountBefore = processedEvent.sdkProcessingMetadata?.spanCountBeforeProcessing || 0;\n          const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;\n\n          const droppedSpanCount = spanCountBefore - spanCountAfter;\n          if (droppedSpanCount > 0) {\n            this.recordDroppedEvent('before_send', 'span', droppedSpanCount);\n          }\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (_isDoNotSendEventError(reason) || _isInternalError(reason)) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason,\n        });\n        throw _makeInternalError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n   _process(promise) {\n    this._numProcessing++;\n    void promise.then(\n      value => {\n        this._numProcessing--;\n        return value;\n      },\n      reason => {\n        this._numProcessing--;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n   _clearOutcomes() {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.entries(outcomes).map(([key, quantity]) => {\n      const [reason, category] = key.split(':') ;\n      return {\n        reason,\n        category,\n        quantity,\n      };\n    });\n  }\n\n  /**\n   * Sends client reports as an envelope.\n   */\n   _flushOutcomes() {\n    DEBUG_BUILD && logger.log('Flushing outcomes...');\n\n    const outcomes = this._clearOutcomes();\n\n    if (outcomes.length === 0) {\n      DEBUG_BUILD && logger.log('No outcomes to send');\n      return;\n    }\n\n    // This is really the only place where we want to check for a DSN and only send outcomes then\n    if (!this._dsn) {\n      DEBUG_BUILD && logger.log('No dsn provided, will not send outcomes');\n      return;\n    }\n\n    DEBUG_BUILD && logger.log('Sending outcomes:', outcomes);\n\n    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(envelope);\n  }\n\n  /**\n   * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n   */\n\n}\n\n/**\n * @deprecated Use `Client` instead. This alias may be removed in a future major version.\n */\n// TODO(v10): Remove\n\n/**\n * @deprecated Use `Client` instead. This alias may be removed in a future major version.\n */\n// TODO(v10): Remove\nconst BaseClient = Client;\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(\n  beforeSendResult,\n  beforeSendLabel,\n) {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(\n      event => {\n        if (!isPlainObject(event) && event !== null) {\n          throw _makeInternalError(invalidValueError);\n        }\n        return event;\n      },\n      e => {\n        throw _makeInternalError(`${beforeSendLabel} rejected with ${e}`);\n      },\n    );\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw _makeInternalError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(\n  client,\n  options,\n  event,\n  hint,\n) {\n  const { beforeSend, beforeSendTransaction, beforeSendSpan } = options;\n  let processedEvent = event;\n\n  if (isErrorEvent(processedEvent) && beforeSend) {\n    return beforeSend(processedEvent, hint);\n  }\n\n  if (isTransactionEvent(processedEvent)) {\n    if (beforeSendSpan) {\n      // process root span\n      const processedRootSpanJson = beforeSendSpan(convertTransactionEventToSpanJson(processedEvent));\n      if (!processedRootSpanJson) {\n        showSpanDropWarning();\n      } else {\n        // update event with processed root span values\n        processedEvent = merge(event, convertSpanJsonToTransactionEvent(processedRootSpanJson));\n      }\n\n      // process child spans\n      if (processedEvent.spans) {\n        const processedSpans = [];\n        for (const span of processedEvent.spans) {\n          const processedSpan = beforeSendSpan(span);\n          if (!processedSpan) {\n            showSpanDropWarning();\n            processedSpans.push(span);\n          } else {\n            processedSpans.push(processedSpan);\n          }\n        }\n        processedEvent.spans = processedSpans;\n      }\n    }\n\n    if (beforeSendTransaction) {\n      if (processedEvent.spans) {\n        // We store the # of spans before processing in SDK metadata,\n        // so we can compare it afterwards to determine how many spans were dropped\n        const spanCountBefore = processedEvent.spans.length;\n        processedEvent.sdkProcessingMetadata = {\n          ...event.sdkProcessingMetadata,\n          spanCountBeforeProcessing: spanCountBefore,\n        };\n      }\n      return beforeSendTransaction(processedEvent , hint);\n    }\n  }\n\n  return processedEvent;\n}\n\nfunction isErrorEvent(event) {\n  return event.type === undefined;\n}\n\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\n\n/** Extract trace information from scope */\nfunction _getTraceInfoFromScope(\n  client,\n  scope,\n) {\n  if (!scope) {\n    return [undefined, undefined];\n  }\n\n  const span = _getSpanForScope(scope);\n  const traceContext = span ? spanToTraceContext(span) : getTraceContextFromScope(scope);\n  const dynamicSamplingContext = span\n    ? getDynamicSamplingContextFromSpan(span)\n    : getDynamicSamplingContextFromScope(client, scope);\n  return [dynamicSamplingContext, traceContext];\n}\n\nexport { BaseClient, Client, _getTraceInfoFromScope };\n//# sourceMappingURL=client.js.map\n"],"names":["ALREADY_SEEN_ERROR","MISSING_RELEASE_FOR_SESSION_ERROR","INTERNAL_ERROR_SYMBOL","DO_NOT_SEND_EVENT_SYMBOL","_makeInternalError","message","_makeDoNotSendEventError","_isInternalError","error","_isDoNotSendEventError","Client","options","makeDsn","DEBUG_BUILD","logger","url","getEnvelopeEndpointWithUrlEncodedAuth","exception","hint","scope","eventId","uuid4","checkOrSetAlreadyCaught","hintWithEventId","event","level","currentScope","eventMessage","isParameterizedString","promisedEvent","isPrimitive","sdkProcessingMetadata","capturedSpanScope","capturedSpanIsolationScope","session","updateSession","timeout","transport","clientFinished","transportFlushed","resolvedSyncPromise","result","eventProcessor","name","integrationName","integration","isAlreadyInstalled","setupIntegration","afterSetupIntegrations","env","createEventEnvelope","attachment","addItemToEnvelope","createAttachmentEnvelopeItem","promise","sendResponse","clientReleaseOption","clientEnvironmentOption","DEFAULT_ENVIRONMENT","sessionAttrs","createSessionEnvelope","reason","category","count","key","hook","callback","hooks","cbIndex","rest","callbacks","envelope","integrations","setupIntegrations","crashed","errored","exceptions","ex","sessionNonTerminal","SyncPromise","resolve","ticked","tick","interval","isolationScope","prepareEvent","evt","getTraceContextFromScope","dynamicSamplingContext","getDynamicSamplingContextFromScope","getCurrentScope","getIsolationScope","isErrorEvent","getPossibleEventMessages","finalEvent","sampleRate","isTransaction","isTransactionEvent","isError","eventType","beforeSendLabel","parsedSampleRate","parseSampleRate","rejectedSyncPromise","dataCategory","prepared","processBeforeSend","_validateBeforeSendResult","processedEvent","spanCount","spanCountBefore","spanCountAfter","droppedSpanCount","transactionInfo","source","value","outcomes","quantity","createClientReportEnvelope","dsnToString","beforeSendResult","invalidValueError","isThenable","isPlainObject","e","client","beforeSend","beforeSendTransaction","beforeSendSpan","processedRootSpanJson","convertTransactionEventToSpanJson","merge","convertSpanJsonToTransactionEvent","showSpanDropWarning","processedSpans","span","processedSpan"],"mappings":"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","x_google_ignoreList":[0]}