{"version":3,"file":"fetch.js","sources":["../../../../../../node_modules/@sentry/core/build/esm/fetch.js"],"sourcesContent":["import { getClient } from './currentScopes.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from './semanticAttributes.js';\nimport './tracing/errors.js';\nimport './debug-build.js';\nimport { isRequest, isInstanceOf } from './utils-hoist/is.js';\nimport './utils-hoist/logger.js';\nimport { hasSpansEnabled } from './utils/hasSpansEnabled.js';\nimport { getActiveSpan } from './utils/spanUtils.js';\nimport './utils-hoist/time.js';\nimport { SENTRY_BAGGAGE_KEY_PREFIX } from './utils-hoist/baggage.js';\nimport { SentryNonRecordingSpan } from './tracing/sentryNonRecordingSpan.js';\nimport { setHttpStatus, SPAN_STATUS_ERROR } from './tracing/spanstatus.js';\nimport { startInactiveSpan } from './tracing/trace.js';\nimport { getTraceData } from './utils/traceData.js';\nimport { parseStringToURLObject, getSanitizedUrlStringFromUrlObject, isURLObjectRelative } from './utils-hoist/url.js';\n\n/**\n * Create and track fetch request spans for usage in combination with `addFetchInstrumentationHandler`.\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction instrumentFetchRequest(\n  handlerData,\n  shouldCreateSpan,\n  shouldAttachHeaders,\n  spans,\n  spanOrigin = 'auto.http.browser',\n) {\n  if (!handlerData.fetchData) {\n    return undefined;\n  }\n\n  const { method, url } = handlerData.fetchData;\n\n  const shouldCreateSpanResult = hasSpansEnabled() && shouldCreateSpan(url);\n\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      endSpan(span, handlerData);\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const hasParent = !!getActiveSpan();\n\n  const span =\n    shouldCreateSpanResult && hasParent\n      ? startInactiveSpan(getSpanStartOptions(url, method, spanOrigin))\n      : new SentryNonRecordingSpan();\n\n  handlerData.fetchData.__span = span.spanContext().spanId;\n  spans[span.spanContext().spanId] = span;\n\n  if (shouldAttachHeaders(handlerData.fetchData.url)) {\n    const request = handlerData.args[0];\n\n    const options = handlerData.args[1] || {};\n\n    const headers = _addTracingHeadersToFetchRequest(\n      request,\n      options,\n      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n      // we do not want to use the span as base for the trace headers,\n      // which means that the headers will be generated from the scope and the sampling decision is deferred\n      hasSpansEnabled() && hasParent ? span : undefined,\n    );\n    if (headers) {\n      // Ensure this is actually set, if no options have been passed previously\n      handlerData.args[1] = options;\n      options.headers = headers;\n    }\n  }\n\n  const client = getClient();\n\n  if (client) {\n    const fetchHint = {\n      input: handlerData.args,\n      response: handlerData.response,\n      startTimestamp: handlerData.startTimestamp,\n      endTimestamp: handlerData.endTimestamp,\n    } ;\n\n    client.emit('beforeOutgoingRequestSpan', span, fetchHint);\n  }\n\n  return span;\n}\n\n/**\n * Adds sentry-trace and baggage headers to the various forms of fetch headers.\n * exported only for testing purposes\n *\n * When we determine if we should add a baggage header, there are 3 cases:\n * 1. No previous baggage header -> add baggage\n * 2. Previous baggage header has no sentry baggage values -> add our baggage\n * 3. Previous baggage header has sentry baggage values -> do nothing (might have been added manually by users)\n */\n// eslint-disable-next-line complexity -- yup it's this complicated :(\nfunction _addTracingHeadersToFetchRequest(\n  request,\n  fetchOptionsObj\n\n,\n  span,\n) {\n  const traceHeaders = getTraceData({ span });\n  const sentryTrace = traceHeaders['sentry-trace'];\n  const baggage = traceHeaders.baggage;\n\n  // Nothing to do, when we return undefined here, the original headers will be used\n  if (!sentryTrace) {\n    return undefined;\n  }\n\n  const originalHeaders = fetchOptionsObj.headers || (isRequest(request) ? request.headers : undefined);\n\n  if (!originalHeaders) {\n    return { ...traceHeaders };\n  } else if (isHeaders(originalHeaders)) {\n    const newHeaders = new Headers(originalHeaders);\n\n    // We don't want to override manually added sentry headers\n    if (!newHeaders.get('sentry-trace')) {\n      newHeaders.set('sentry-trace', sentryTrace);\n    }\n\n    if (baggage) {\n      const prevBaggageHeader = newHeaders.get('baggage');\n\n      if (!prevBaggageHeader) {\n        newHeaders.set('baggage', baggage);\n      } else if (!baggageHeaderHasSentryBaggageValues(prevBaggageHeader)) {\n        newHeaders.set('baggage', `${prevBaggageHeader},${baggage}`);\n      }\n    }\n\n    return newHeaders;\n  } else if (Array.isArray(originalHeaders)) {\n    const newHeaders = [...originalHeaders];\n\n    if (!originalHeaders.find(header => header[0] === 'sentry-trace')) {\n      newHeaders.push(['sentry-trace', sentryTrace]);\n    }\n\n    const prevBaggageHeaderWithSentryValues = originalHeaders.find(\n      header => header[0] === 'baggage' && baggageHeaderHasSentryBaggageValues(header[1]),\n    );\n\n    if (baggage && !prevBaggageHeaderWithSentryValues) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push(['baggage', baggage]);\n    }\n\n    return newHeaders ;\n  } else {\n    const existingSentryTraceHeader = 'sentry-trace' in originalHeaders ? originalHeaders['sentry-trace'] : undefined;\n\n    const existingBaggageHeader = 'baggage' in originalHeaders ? originalHeaders.baggage : undefined;\n    const newBaggageHeaders = existingBaggageHeader\n      ? Array.isArray(existingBaggageHeader)\n        ? [...existingBaggageHeader]\n        : [existingBaggageHeader]\n      : [];\n\n    const prevBaggageHeaderWithSentryValues =\n      existingBaggageHeader &&\n      (Array.isArray(existingBaggageHeader)\n        ? existingBaggageHeader.find(headerItem => baggageHeaderHasSentryBaggageValues(headerItem))\n        : baggageHeaderHasSentryBaggageValues(existingBaggageHeader));\n\n    if (baggage && !prevBaggageHeaderWithSentryValues) {\n      newBaggageHeaders.push(baggage);\n    }\n\n    return {\n      ...(originalHeaders ),\n      'sentry-trace': (existingSentryTraceHeader ) ?? sentryTrace,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined,\n    };\n  }\n}\n\nfunction endSpan(span, handlerData) {\n  if (handlerData.response) {\n    setHttpStatus(span, handlerData.response.status);\n\n    const contentLength = handlerData.response?.headers && handlerData.response.headers.get('content-length');\n\n    if (contentLength) {\n      const contentLengthNum = parseInt(contentLength);\n      if (contentLengthNum > 0) {\n        span.setAttribute('http.response_content_length', contentLengthNum);\n      }\n    }\n  } else if (handlerData.error) {\n    span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n  }\n  span.end();\n}\n\nfunction baggageHeaderHasSentryBaggageValues(baggageHeader) {\n  return baggageHeader.split(',').some(baggageEntry => baggageEntry.trim().startsWith(SENTRY_BAGGAGE_KEY_PREFIX));\n}\n\nfunction isHeaders(headers) {\n  return typeof Headers !== 'undefined' && isInstanceOf(headers, Headers);\n}\n\nfunction getSpanStartOptions(\n  url,\n  method,\n  spanOrigin,\n) {\n  const parsedUrl = parseStringToURLObject(url);\n  return {\n    name: parsedUrl ? `${method} ${getSanitizedUrlStringFromUrlObject(parsedUrl)}` : method,\n    attributes: getFetchSpanAttributes(url, parsedUrl, method, spanOrigin),\n  };\n}\n\nfunction getFetchSpanAttributes(\n  url,\n  parsedUrl,\n  method,\n  spanOrigin,\n) {\n  const attributes = {\n    url,\n    type: 'fetch',\n    'http.method': method,\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin,\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n  };\n  if (parsedUrl) {\n    if (!isURLObjectRelative(parsedUrl)) {\n      attributes['http.url'] = parsedUrl.href;\n      attributes['server.address'] = parsedUrl.host;\n    }\n    if (parsedUrl.search) {\n      attributes['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      attributes['http.fragment'] = parsedUrl.hash;\n    }\n  }\n  return attributes;\n}\n\nexport { _addTracingHeadersToFetchRequest, instrumentFetchRequest };\n//# sourceMappingURL=fetch.js.map\n"],"names":["instrumentFetchRequest","handlerData","shouldCreateSpan","shouldAttachHeaders","spans","spanOrigin","method","url","shouldCreateSpanResult","hasSpansEnabled","spanId","span","endSpan","hasParent","getActiveSpan","startInactiveSpan","getSpanStartOptions","SentryNonRecordingSpan","request","options","headers","_addTracingHeadersToFetchRequest","client","getClient","fetchHint","fetchOptionsObj","traceHeaders","getTraceData","sentryTrace","baggage","originalHeaders","isRequest","isHeaders","newHeaders","prevBaggageHeader","baggageHeaderHasSentryBaggageValues","header","prevBaggageHeaderWithSentryValues","existingSentryTraceHeader","existingBaggageHeader","newBaggageHeaders","headerItem","setHttpStatus","contentLength","contentLengthNum","SPAN_STATUS_ERROR","baggageHeader","baggageEntry","SENTRY_BAGGAGE_KEY_PREFIX","isInstanceOf","parsedUrl","parseStringToURLObject","getSanitizedUrlStringFromUrlObject","getFetchSpanAttributes","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","isURLObjectRelative"],"mappings":"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","x_google_ignoreList":[0]}