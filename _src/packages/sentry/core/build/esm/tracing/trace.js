import{getAsyncContextStrategy as A}from"../asyncContext/index.js";import{getMainCarrier as w}from"../carrier.js";import{withScope as T,getCurrentScope as h,getClient as m,getIsolationScope as b}from"../currentScopes.js";import{DEBUG_BUILD as D}from"../debug-build.js";import{SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE as N,SEMANTIC_ATTRIBUTE_SENTRY_SOURCE as y}from"../semanticAttributes.js";import{hasSpansEnabled as v}from"../utils/hasSpansEnabled.js";import{parseSampleRate as U}from"../utils/parseSampleRate.js";import{_getSpanForScope as M,_setSpanForScope as O}from"../utils/spanOnScope.js";import{spanTimeInputToSeconds as B,getRootSpan as Y,addChildSpanToSpan as _,spanIsSampled as C}from"../utils/spanUtils.js";import{logger as k}from"../utils-hoist/logger.js";import{getDynamicSamplingContextFromSpan as g,freezeDscOnSpan as S}from"./dynamicSamplingContext.js";import{logSpanStart as F}from"./logSpans.js";import{sampleSpan as G}from"./sampling.js";import{SentryNonRecordingSpan as d}from"./sentryNonRecordingSpan.js";import{SentrySpan as R}from"./sentrySpan.js";import{setCapturedScopesOnSpan as L}from"./utils.js";const E="__SENTRY_SUPPRESS_TRACING__";function ct(t){const a=P();if(a.startInactiveSpan)return a.startInactiveSpan(t);const r=W(t),{forceTransaction:e,parentSpan:i}=t;return(t.scope?n=>T(t.scope,n):i!==void 0?n=>z(i,n):n=>n())(()=>{const n=h(),s=q(n);return t.onlyIfParent&&!s?new d:K({parentSpan:s,spanArguments:r,forceTransaction:e,scope:n})})}function z(t,a){const r=P();return r.withActiveSpan?r.withActiveSpan(t,a):T(e=>(O(e,t||void 0),a(e)))}function K({parentSpan:t,spanArguments:a,forceTransaction:r,scope:e}){if(!v()){const n=new d;if(r||!t){const s={sampled:"false",sample_rate:"0",transaction:a.name,...g(n)};S(n,s)}return n}const i=b();let o;if(t&&!r)o=j(t,e,a),_(t,o);else if(t){const n=g(t),{traceId:s,spanId:p}=t.spanContext(),c=C(t);o=I({traceId:s,parentSpanId:p,...a},e,c),S(o,n)}else{const{traceId:n,dsc:s,parentSpanId:p,sampled:c}={...i.getPropagationContext(),...e.getPropagationContext()};o=I({traceId:n,parentSpanId:p,...a},e,c),s&&S(o,s)}return F(o),L(o,e,i),o}function W(t){const r={isStandalone:(t.experimental||{}).standalone,...t};if(t.startTime){const e={...r};return e.startTimestamp=B(t.startTime),delete e.startTime,e}return r}function P(){const t=w();return A(t)}function I(t,a,r){const e=m(),i=e?.getOptions()||{},{name:o=""}=t,n={spanAttributes:{...t.attributes},spanName:o,parentSampled:r};e?.emit("beforeSampling",n,{decision:!1});const s=n.parentSampled??r,p=n.spanAttributes,c=a.getPropagationContext(),[l,f,x]=a.getScopeData().sdkProcessingMetadata[E]?[!1]:G(i,{name:o,parentSampled:s,attributes:p,parentSampleRate:U(c.dsc?.sample_rate)},c.sampleRand),u=new R({...t,attributes:{[y]:"custom",[N]:f!==void 0&&x?f:void 0,...p},sampled:l});return!l&&e&&(D&&k.log("[Tracing] Discarding root span because its trace was not chosen to be sampled."),e.recordDroppedEvent("sample_rate","transaction")),e&&e.emit("spanStart",u),u}function j(t,a,r){const{spanId:e,traceId:i}=t.spanContext(),o=a.getScopeData().sdkProcessingMetadata[E]?!1:C(t),n=o?new R({...r,parentSpanId:e,traceId:i,sampled:o}):new d({traceId:i});_(t,n);const s=m();return s&&(s.emit("spanStart",n),r.endTimestamp&&s.emit("spanEnd",n)),n}function q(t){const a=M(t);if(!a)return;const r=m();return(r?r.getOptions():{}).parentSpanIsAlwaysRootSpan?Y(a):a}export{ct as startInactiveSpan,z as withActiveSpan};
//# sourceMappingURL=trace.js.map
