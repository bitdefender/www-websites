{"version":3,"file":"idleSpan.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/tracing/idleSpan.js"],"sourcesContent":["import { getClient, getCurrentScope } from '../currentScopes.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON } from '../semanticAttributes.js';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled.js';\nimport { _setSpanForScope } from '../utils/spanOnScope.js';\nimport { getActiveSpan, spanTimeInputToSeconds, getSpanDescendants, spanToJSON, removeChildSpanFromSpan } from '../utils/spanUtils.js';\nimport { logger } from '../utils-hoist/logger.js';\nimport { timestampInSeconds } from '../utils-hoist/time.js';\nimport { getDynamicSamplingContextFromSpan, freezeDscOnSpan } from './dynamicSamplingContext.js';\nimport { SentryNonRecordingSpan } from './sentryNonRecordingSpan.js';\nimport { SPAN_STATUS_ERROR } from './spanstatus.js';\nimport { startInactiveSpan } from './trace.js';\n\nconst TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  childSpanTimeout: 15000,\n};\n\nconst FINISH_REASON_HEARTBEAT_FAILED = 'heartbeatFailed';\nconst FINISH_REASON_IDLE_TIMEOUT = 'idleTimeout';\nconst FINISH_REASON_FINAL_TIMEOUT = 'finalTimeout';\nconst FINISH_REASON_EXTERNAL_FINISH = 'externalFinish';\n\n/**\n * An idle span is a span that automatically finishes. It does this by tracking child spans as activities.\n * An idle span is always the active span.\n */\nfunction startIdleSpan(startSpanOptions, options = {}) {\n  // Activities store a list of active spans\n  const activities = new Map();\n\n  // We should not use heartbeat if we finished a span\n  let _finished = false;\n\n  // Timer that tracks idleTimeout\n  let _idleTimeoutID;\n\n  // The reason why the span was finished\n  let _finishReason = FINISH_REASON_EXTERNAL_FINISH;\n\n  let _autoFinishAllowed = !options.disableAutoFinish;\n\n  const _cleanupHooks = [];\n\n  const {\n    idleTimeout = TRACING_DEFAULTS.idleTimeout,\n    finalTimeout = TRACING_DEFAULTS.finalTimeout,\n    childSpanTimeout = TRACING_DEFAULTS.childSpanTimeout,\n    beforeSpanEnd,\n  } = options;\n\n  const client = getClient();\n\n  if (!client || !hasSpansEnabled()) {\n    const span = new SentryNonRecordingSpan();\n\n    const dsc = {\n      sample_rate: '0',\n      sampled: 'false',\n      ...getDynamicSamplingContextFromSpan(span),\n    } ;\n    freezeDscOnSpan(span, dsc);\n\n    return span;\n  }\n\n  const scope = getCurrentScope();\n  const previousActiveSpan = getActiveSpan();\n  const span = _startIdleSpan(startSpanOptions);\n\n  // We patch span.end to ensure we can run some things before the span is ended\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  span.end = new Proxy(span.end, {\n    apply(target, thisArg, args) {\n      if (beforeSpanEnd) {\n        beforeSpanEnd(span);\n      }\n\n      // If the span is non-recording, nothing more to do here...\n      // This is the case if tracing is enabled but this specific span was not sampled\n      if (thisArg instanceof SentryNonRecordingSpan) {\n        return;\n      }\n\n      // Just ensuring that this keeps working, even if we ever have more arguments here\n      const [definedEndTimestamp, ...rest] = args;\n      const timestamp = definedEndTimestamp || timestampInSeconds();\n      const spanEndTimestamp = spanTimeInputToSeconds(timestamp);\n\n      // Ensure we end with the last span timestamp, if possible\n      const spans = getSpanDescendants(span).filter(child => child !== span);\n\n      // If we have no spans, we just end, nothing else to do here\n      if (!spans.length) {\n        onIdleSpanEnded(spanEndTimestamp);\n        return Reflect.apply(target, thisArg, [spanEndTimestamp, ...rest]);\n      }\n\n      const childEndTimestamps = spans\n        .map(span => spanToJSON(span).timestamp)\n        .filter(timestamp => !!timestamp) ;\n      const latestSpanEndTimestamp = childEndTimestamps.length ? Math.max(...childEndTimestamps) : undefined;\n\n      // In reality this should always exist here, but type-wise it may be undefined...\n      const spanStartTimestamp = spanToJSON(span).start_timestamp;\n\n      // The final endTimestamp should:\n      // * Never be before the span start timestamp\n      // * Be the latestSpanEndTimestamp, if there is one, and it is smaller than the passed span end timestamp\n      // * Otherwise be the passed end timestamp\n      // Final timestamp can never be after finalTimeout\n      const endTimestamp = Math.min(\n        spanStartTimestamp ? spanStartTimestamp + finalTimeout / 1000 : Infinity,\n        Math.max(spanStartTimestamp || -Infinity, Math.min(spanEndTimestamp, latestSpanEndTimestamp || Infinity)),\n      );\n\n      onIdleSpanEnded(endTimestamp);\n      return Reflect.apply(target, thisArg, [endTimestamp, ...rest]);\n    },\n  });\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   */\n  function _cancelIdleTimeout() {\n    if (_idleTimeoutID) {\n      clearTimeout(_idleTimeoutID);\n      _idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  function _restartIdleTimeout(endTimestamp) {\n    _cancelIdleTimeout();\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && activities.size === 0 && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_IDLE_TIMEOUT;\n        span.end(endTimestamp);\n      }\n    }, idleTimeout);\n  }\n\n  /**\n   * Restarts child span timeout, if there is none running it will start one.\n   */\n  function _restartChildSpanTimeout(endTimestamp) {\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_HEARTBEAT_FAILED;\n        span.end(endTimestamp);\n      }\n    }, childSpanTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  function _pushActivity(spanId) {\n    _cancelIdleTimeout();\n    activities.set(spanId, true);\n\n    const endTimestamp = timestampInSeconds();\n    // We need to add the timeout here to have the real endtimestamp of the idle span\n    // Remember timestampInSeconds is in seconds, timeout is in ms\n    _restartChildSpanTimeout(endTimestamp + childSpanTimeout / 1000);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  function _popActivity(spanId) {\n    if (activities.has(spanId)) {\n      activities.delete(spanId);\n    }\n\n    if (activities.size === 0) {\n      const endTimestamp = timestampInSeconds();\n      // We need to add the timeout here to have the real endtimestamp of the idle span\n      // Remember timestampInSeconds is in seconds, timeout is in ms\n      _restartIdleTimeout(endTimestamp + idleTimeout / 1000);\n    }\n  }\n\n  function onIdleSpanEnded(endTimestamp) {\n    _finished = true;\n    activities.clear();\n\n    _cleanupHooks.forEach(cleanup => cleanup());\n\n    _setSpanForScope(scope, previousActiveSpan);\n\n    const spanJSON = spanToJSON(span);\n\n    const { start_timestamp: startTimestamp } = spanJSON;\n    // This should never happen, but to make TS happy...\n    if (!startTimestamp) {\n      return;\n    }\n\n    const attributes = spanJSON.data;\n    if (!attributes[SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON]) {\n      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, _finishReason);\n    }\n\n    logger.log(`[Tracing] Idle span \"${spanJSON.op}\" finished`);\n\n    const childSpans = getSpanDescendants(span).filter(child => child !== span);\n\n    let discardedSpans = 0;\n    childSpans.forEach(childSpan => {\n      // We cancel all pending spans with status \"cancelled\" to indicate the idle span was finished early\n      if (childSpan.isRecording()) {\n        childSpan.setStatus({ code: SPAN_STATUS_ERROR, message: 'cancelled' });\n        childSpan.end(endTimestamp);\n        DEBUG_BUILD &&\n          logger.log('[Tracing] Cancelling span since span ended early', JSON.stringify(childSpan, undefined, 2));\n      }\n\n      const childSpanJSON = spanToJSON(childSpan);\n      const { timestamp: childEndTimestamp = 0, start_timestamp: childStartTimestamp = 0 } = childSpanJSON;\n\n      const spanStartedBeforeIdleSpanEnd = childStartTimestamp <= endTimestamp;\n\n      // Add a delta with idle timeout so that we prevent false positives\n      const timeoutWithMarginOfError = (finalTimeout + idleTimeout) / 1000;\n      const spanEndedBeforeFinalTimeout = childEndTimestamp - childStartTimestamp <= timeoutWithMarginOfError;\n\n      if (DEBUG_BUILD) {\n        const stringifiedSpan = JSON.stringify(childSpan, undefined, 2);\n        if (!spanStartedBeforeIdleSpanEnd) {\n          logger.log('[Tracing] Discarding span since it happened after idle span was finished', stringifiedSpan);\n        } else if (!spanEndedBeforeFinalTimeout) {\n          logger.log('[Tracing] Discarding span since it finished after idle span final timeout', stringifiedSpan);\n        }\n      }\n\n      if (!spanEndedBeforeFinalTimeout || !spanStartedBeforeIdleSpanEnd) {\n        removeChildSpanFromSpan(span, childSpan);\n        discardedSpans++;\n      }\n    });\n\n    if (discardedSpans > 0) {\n      span.setAttribute('sentry.idle_span_discarded_spans', discardedSpans);\n    }\n  }\n\n  _cleanupHooks.push(\n    client.on('spanStart', startedSpan => {\n      // If we already finished the idle span,\n      // or if this is the idle span itself being started,\n      // or if the started span has already been closed,\n      // we don't care about it for activity\n      if (_finished || startedSpan === span || !!spanToJSON(startedSpan).timestamp) {\n        return;\n      }\n\n      const allSpans = getSpanDescendants(span);\n\n      // If the span that was just started is a child of the idle span, we should track it\n      if (allSpans.includes(startedSpan)) {\n        _pushActivity(startedSpan.spanContext().spanId);\n      }\n    }),\n  );\n\n  _cleanupHooks.push(\n    client.on('spanEnd', endedSpan => {\n      if (_finished) {\n        return;\n      }\n\n      _popActivity(endedSpan.spanContext().spanId);\n    }),\n  );\n\n  _cleanupHooks.push(\n    client.on('idleSpanEnableAutoFinish', spanToAllowAutoFinish => {\n      if (spanToAllowAutoFinish === span) {\n        _autoFinishAllowed = true;\n        _restartIdleTimeout();\n\n        if (activities.size) {\n          _restartChildSpanTimeout();\n        }\n      }\n    }),\n  );\n\n  // We only start the initial idle timeout if we are not delaying the auto finish\n  if (!options.disableAutoFinish) {\n    _restartIdleTimeout();\n  }\n\n  setTimeout(() => {\n    if (!_finished) {\n      span.setStatus({ code: SPAN_STATUS_ERROR, message: 'deadline_exceeded' });\n      _finishReason = FINISH_REASON_FINAL_TIMEOUT;\n      span.end();\n    }\n  }, finalTimeout);\n\n  return span;\n}\n\nfunction _startIdleSpan(options) {\n  const span = startInactiveSpan(options);\n\n  _setSpanForScope(getCurrentScope(), span);\n\n  DEBUG_BUILD && logger.log('[Tracing] Started span is an idle span');\n\n  return span;\n}\n\nexport { TRACING_DEFAULTS, startIdleSpan };\n//# sourceMappingURL=idleSpan.js.map\n"],"names":["TRACING_DEFAULTS","FINISH_REASON_HEARTBEAT_FAILED","FINISH_REASON_IDLE_TIMEOUT","FINISH_REASON_FINAL_TIMEOUT","FINISH_REASON_EXTERNAL_FINISH","startIdleSpan","startSpanOptions","options","activities","_finished","_idleTimeoutID","_finishReason","_autoFinishAllowed","_cleanupHooks","idleTimeout","finalTimeout","childSpanTimeout","beforeSpanEnd","client","getClient","hasSpansEnabled","span","SentryNonRecordingSpan","dsc","getDynamicSamplingContextFromSpan","freezeDscOnSpan","scope","getCurrentScope","previousActiveSpan","getActiveSpan","_startIdleSpan","target","thisArg","args","definedEndTimestamp","rest","timestamp","timestampInSeconds","spanEndTimestamp","spanTimeInputToSeconds","spans","getSpanDescendants","child","onIdleSpanEnded","childEndTimestamps","spanToJSON","latestSpanEndTimestamp","spanStartTimestamp","endTimestamp","_cancelIdleTimeout","_restartIdleTimeout","_restartChildSpanTimeout","_pushActivity","spanId","_popActivity","cleanup","_setSpanForScope","spanJSON","startTimestamp","SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON","logger","childSpans","discardedSpans","childSpan","SPAN_STATUS_ERROR","DEBUG_BUILD","childSpanJSON","childEndTimestamp","childStartTimestamp","spanStartedBeforeIdleSpanEnd","timeoutWithMarginOfError","spanEndedBeforeFinalTimeout","stringifiedSpan","removeChildSpanFromSpan","startedSpan","endedSpan","spanToAllowAutoFinish","startInactiveSpan"],"mappings":"81BAaK,MAACA,EAAmB,CACvB,YAAa,IACb,aAAc,IACd,iBAAkB,IACpB,EAEMC,GAAiC,kBACjCC,GAA6B,cAC7BC,GAA8B,eAC9BC,GAAgC,iBAMtC,SAASC,GAAcC,EAAkBC,EAAU,GAAI,CAErD,MAAMC,EAAa,IAAI,IAGvB,IAAIC,EAAY,GAGZC,EAGAC,EAAgBP,GAEhBQ,EAAqB,CAACL,EAAQ,kBAElC,MAAMM,EAAgB,CAAE,EAElB,CACJ,YAAAC,EAAcd,EAAiB,YAC/B,aAAAe,EAAef,EAAiB,aAChC,iBAAAgB,EAAmBhB,EAAiB,iBACpC,cAAAiB,CACJ,EAAMV,EAEEW,EAASC,EAAW,EAE1B,GAAI,CAACD,GAAU,CAACE,IAAmB,CACjC,MAAMC,EAAO,IAAIC,EAEXC,EAAM,CACV,YAAa,IACb,QAAS,QACT,GAAGC,EAAkCH,CAAI,CAC1C,EACD,OAAAI,EAAgBJ,EAAME,CAAG,EAElBF,CACX,CAEE,MAAMK,EAAQC,EAAiB,EACzBC,EAAqBC,EAAe,EACpCR,EAAOS,GAAexB,CAAgB,EAI5Ce,EAAK,IAAM,IAAI,MAAMA,EAAK,IAAK,CAC7B,MAAMU,EAAQC,EAASC,EAAM,CAO3B,GANIhB,GACFA,EAAcI,CAAI,EAKhBW,aAAmBV,EACrB,OAIF,KAAM,CAACY,EAAqB,GAAGC,CAAI,EAAIF,EACjCG,EAAYF,GAAuBG,EAAoB,EACvDC,EAAmBC,EAAuBH,CAAS,EAGnDI,EAAQC,EAAmBpB,CAAI,EAAE,OAAOqB,GAASA,IAAUrB,CAAI,EAGrE,GAAI,CAACmB,EAAM,OACT,OAAAG,EAAgBL,CAAgB,EACzB,QAAQ,MAAMP,EAAQC,EAAS,CAACM,EAAkB,GAAGH,CAAI,CAAC,EAGnE,MAAMS,EAAqBJ,EACxB,IAAInB,GAAQwB,EAAWxB,CAAI,EAAE,SAAS,EACtC,OAAOe,GAAa,CAAC,CAACA,CAAS,EAC5BU,EAAyBF,EAAmB,OAAS,KAAK,IAAI,GAAGA,CAAkB,EAAI,OAGvFG,EAAqBF,EAAWxB,CAAI,EAAE,gBAOtC2B,EAAe,KAAK,IACxBD,EAAqBA,EAAqBhC,EAAe,IAAO,IAChE,KAAK,IAAIgC,GAAsB,KAAW,KAAK,IAAIT,EAAkBQ,GAA0B,GAAQ,CAAC,CACzG,EAED,OAAAH,EAAgBK,CAAY,EACrB,QAAQ,MAAMjB,EAAQC,EAAS,CAACgB,EAAc,GAAGb,CAAI,CAAC,CAC9D,CACL,CAAG,EAKD,SAASc,GAAqB,CACxBvC,IACF,aAAaA,CAAc,EAC3BA,EAAiB,OAEvB,CAKE,SAASwC,EAAoBF,EAAc,CACzCC,EAAoB,EACpBvC,EAAiB,WAAW,IAAM,CAC5B,CAACD,GAAaD,EAAW,OAAS,GAAKI,IACzCD,EAAgBT,GAChBmB,EAAK,IAAI2B,CAAY,EAExB,EAAElC,CAAW,CAClB,CAKE,SAASqC,EAAyBH,EAAc,CAC9CtC,EAAiB,WAAW,IAAM,CAC5B,CAACD,GAAaG,IAChBD,EAAgBV,GAChBoB,EAAK,IAAI2B,CAAY,EAExB,EAAEhC,CAAgB,CACvB,CAME,SAASoC,EAAcC,EAAQ,CAC7BJ,EAAoB,EACpBzC,EAAW,IAAI6C,EAAQ,EAAI,EAE3B,MAAML,EAAeX,EAAoB,EAGzCc,EAAyBH,EAAehC,EAAmB,GAAI,CACnE,CAME,SAASsC,EAAaD,EAAQ,CAK5B,GAJI7C,EAAW,IAAI6C,CAAM,GACvB7C,EAAW,OAAO6C,CAAM,EAGtB7C,EAAW,OAAS,EAAG,CACzB,MAAMwC,EAAeX,EAAoB,EAGzCa,EAAoBF,EAAelC,EAAc,GAAI,CAC3D,CACA,CAEE,SAAS6B,EAAgBK,EAAc,CACrCvC,EAAY,GACZD,EAAW,MAAO,EAElBK,EAAc,QAAQ0C,GAAWA,GAAS,EAE1CC,EAAiB9B,EAAOE,CAAkB,EAE1C,MAAM6B,EAAWZ,EAAWxB,CAAI,EAE1B,CAAE,gBAAiBqC,CAAc,EAAKD,EAE5C,GAAI,CAACC,EACH,OAGiBD,EAAS,KACZE,CAAiD,GAC/DtC,EAAK,aAAasC,EAAmDhD,CAAa,EAGpFiD,EAAO,IAAI,wBAAwBH,EAAS,EAAE,YAAY,EAE1D,MAAMI,EAAapB,EAAmBpB,CAAI,EAAE,OAAOqB,GAASA,IAAUrB,CAAI,EAE1E,IAAIyC,EAAiB,EACrBD,EAAW,QAAQE,GAAa,CAE1BA,EAAU,gBACZA,EAAU,UAAU,CAAE,KAAMC,EAAmB,QAAS,YAAa,EACrED,EAAU,IAAIf,CAAY,EAC1BiB,GACEL,EAAO,IAAI,mDAAoD,KAAK,UAAUG,EAAW,OAAW,CAAC,CAAC,GAG1G,MAAMG,EAAgBrB,EAAWkB,CAAS,EACpC,CAAE,UAAWI,EAAoB,EAAG,gBAAiBC,EAAsB,CAAC,EAAKF,EAEjFG,EAA+BD,GAAuBpB,EAGtDsB,GAA4BvD,EAAeD,GAAe,IAC1DyD,EAA8BJ,EAAoBC,GAAuBE,EAE/E,GAAIL,EAAa,CACf,MAAMO,EAAkB,KAAK,UAAUT,EAAW,OAAW,CAAC,EACzDM,EAEOE,GACVX,EAAO,IAAI,4EAA6EY,CAAe,EAFvGZ,EAAO,IAAI,2EAA4EY,CAAe,CAIhH,EAEU,CAACD,GAA+B,CAACF,KACnCI,EAAwBpD,EAAM0C,CAAS,EACvCD,IAER,CAAK,EAEGA,EAAiB,GACnBzC,EAAK,aAAa,mCAAoCyC,CAAc,CAE1E,CAEE,OAAAjD,EAAc,KACZK,EAAO,GAAG,YAAawD,GAAe,CAKpC,GAAIjE,GAAaiE,IAAgBrD,GAAUwB,EAAW6B,CAAW,EAAE,UACjE,OAGejC,EAAmBpB,CAAI,EAG3B,SAASqD,CAAW,GAC/BtB,EAAcsB,EAAY,YAAa,EAAC,MAAM,CAEtD,CAAK,CACF,EAED7D,EAAc,KACZK,EAAO,GAAG,UAAWyD,GAAa,CAC5BlE,GAIJ6C,EAAaqB,EAAU,YAAa,EAAC,MAAM,CACjD,CAAK,CACF,EAED9D,EAAc,KACZK,EAAO,GAAG,2BAA4B0D,GAAyB,CACzDA,IAA0BvD,IAC5BT,EAAqB,GACrBsC,EAAqB,EAEjB1C,EAAW,MACb2C,EAA0B,EAGpC,CAAK,CACF,EAGI5C,EAAQ,mBACX2C,EAAqB,EAGvB,WAAW,IAAM,CACVzC,IACHY,EAAK,UAAU,CAAE,KAAM2C,EAAmB,QAAS,oBAAqB,EACxErD,EAAgBR,GAChBkB,EAAK,IAAK,EAEb,EAAEN,CAAY,EAERM,CACT,CAEA,SAASS,GAAevB,EAAS,CAC/B,MAAMc,EAAOwD,GAAkBtE,CAAO,EAEtC,OAAAiD,EAAiB7B,EAAiB,EAAEN,CAAI,EAExC4C,GAAeL,EAAO,IAAI,wCAAwC,EAE3DvC,CACT","x_google_ignoreList":[0]}