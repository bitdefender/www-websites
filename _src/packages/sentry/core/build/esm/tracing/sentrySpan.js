import{getClient as R,getCurrentScope as v}from"../currentScopes.js";import{DEBUG_BUILD as d}from"../debug-build.js";import{createSpanEnvelope as k}from"../envelope.js";import{SEMANTIC_ATTRIBUTE_SENTRY_OP as S,SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN as u,SEMANTIC_ATTRIBUTE_SENTRY_SOURCE as l,SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME as U,SEMANTIC_ATTRIBUTE_PROFILE_ID as D,SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME as T}from"../semanticAttributes.js";import{TRACE_FLAG_SAMPLED as O,TRACE_FLAG_NONE as L,spanTimeInputToSeconds as m,convertSpanLinksForEnvelope as y,getRootSpan as h,getStatusMessage as B,spanToJSON as f,getSpanDescendants as F,spanToTransactionTraceContext as C}from"../utils/spanUtils.js";import{logger as p}from"../utils-hoist/logger.js";import{generateTraceId as P,generateSpanId as G}from"../utils-hoist/propagationContext.js";import{timestampInSeconds as E}from"../utils-hoist/time.js";import{getDynamicSamplingContextFromSpan as Y}from"./dynamicSamplingContext.js";import{logSpanEnd as q}from"./logSpans.js";import{timedEventsToMeasurements as I}from"./measurement.js";import{getCapturedScopesOnSpan as g}from"./utils.js";const A=1e3;class J{constructor(t={}){this._traceId=t.traceId||P(),this._spanId=t.spanId||G(),this._startTime=t.startTimestamp||E(),this._links=t.links,this._attributes={},this.setAttributes({[u]:"manual",[S]:t.op,...t.attributes}),this._name=t.name,t.parentSpanId&&(this._parentSpanId=t.parentSpanId),"sampled"in t&&(this._sampled=t.sampled),t.endTimestamp&&(this._endTime=t.endTimestamp),this._events=[],this._isStandaloneSpan=t.isStandalone,this._endTime&&this._onSpanEnded()}addLink(t){return this._links?this._links.push(t):this._links=[t],this}addLinks(t){return this._links?this._links.push(...t):this._links=t,this}recordException(t,e){}spanContext(){const{_spanId:t,_traceId:e,_sampled:n}=this;return{spanId:t,traceId:e,traceFlags:n?O:L}}setAttribute(t,e){return e===void 0?delete this._attributes[t]:this._attributes[t]=e,this}setAttributes(t){return Object.keys(t).forEach(e=>this.setAttribute(e,t[e])),this}updateStartTime(t){this._startTime=m(t)}setStatus(t){return this._status=t,this}updateName(t){return this._name=t,this.setAttribute(l,"custom"),this}end(t){this._endTime||(this._endTime=m(t),q(this),this._onSpanEnded())}getSpanJSON(){return{data:this._attributes,description:this._name,op:this._attributes[S],parent_span_id:this._parentSpanId,span_id:this._spanId,start_timestamp:this._startTime,status:B(this._status),timestamp:this._endTime,trace_id:this._traceId,origin:this._attributes[u],profile_id:this._attributes[D],exclusive_time:this._attributes[U],measurements:I(this._events),is_segment:this._isStandaloneSpan&&h(this)===this||void 0,segment_id:this._isStandaloneSpan?h(this).spanContext().spanId:void 0,links:y(this._links)}}isRecording(){return!this._endTime&&!!this._sampled}addEvent(t,e,n){d&&p.log("[Tracing] Adding an event to span:",t);const _=b(e)?e:n||E(),a=b(e)?{}:e||{},r={name:t,time:m(_),attributes:a};return this._events.push(r),this}isStandaloneSpan(){return!!this._isStandaloneSpan}_onSpanEnded(){const t=R();if(t&&t.emit("spanEnd",this),!(this._isStandaloneSpan||this===h(this)))return;if(this._isStandaloneSpan){this._sampled?w(k([this],t)):(d&&p.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."),t&&t.recordDroppedEvent("sample_rate","span"));return}const n=this._convertSpanToTransaction();n&&(g(this).scope||v()).captureEvent(n)}_convertSpanToTransaction(){if(!N(f(this)))return;this._name||(d&&p.warn("Transaction has no name, falling back to `<unlabeled transaction>`."),this._name="<unlabeled transaction>");const{scope:t,isolationScope:e}=g(this),n=t?.getScopeData().sdkProcessingMetadata?.normalizedRequest;if(this._sampled!==!0)return;const a=F(this).filter(i=>i!==this&&!j(i)).map(i=>f(i)).filter(N),r=this._attributes[l];delete this._attributes[T],a.forEach(i=>{delete i.data[T]});const c={contexts:{trace:C(this)},spans:a.length>A?a.sort((i,M)=>i.start_timestamp-M.start_timestamp).slice(0,A):a,start_timestamp:this._startTime,timestamp:this._endTime,transaction:this._name,type:"transaction",sdkProcessingMetadata:{capturedSpanScope:t,capturedSpanIsolationScope:e,dynamicSamplingContext:Y(this)},request:n,...r&&{transaction_info:{source:r}}},o=I(this._events);return o&&Object.keys(o).length&&(d&&p.log("[Measurements] Adding measurements to transaction event",JSON.stringify(o,void 0,2)),c.measurements=o),c}}function b(s){return s&&typeof s=="number"||s instanceof Date||Array.isArray(s)}function N(s){return!!s.start_timestamp&&!!s.timestamp&&!!s.span_id&&!!s.trace_id}function j(s){return s instanceof J&&s.isStandaloneSpan()}function w(s){const t=R();if(!t)return;const e=s[1];if(!e||e.length===0){t.recordDroppedEvent("before_send","span");return}t.sendEnvelope(s)}export{J as SentrySpan};
//# sourceMappingURL=sentrySpan.js.map
