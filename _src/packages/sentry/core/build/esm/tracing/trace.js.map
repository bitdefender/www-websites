{"version":3,"file":"trace.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/tracing/trace.js"],"sourcesContent":["import { getAsyncContextStrategy } from '../asyncContext/index.js';\nimport { getMainCarrier } from '../carrier.js';\nimport { withScope, getCurrentScope, getClient, getIsolationScope } from '../currentScopes.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '../semanticAttributes.js';\nimport { handleCallbackErrors } from '../utils/handleCallbackErrors.js';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled.js';\nimport { parseSampleRate } from '../utils/parseSampleRate.js';\nimport { _setSpanForScope, _getSpanForScope } from '../utils/spanOnScope.js';\nimport { spanToJSON, spanTimeInputToSeconds, getRootSpan, addChildSpanToSpan, spanIsSampled } from '../utils/spanUtils.js';\nimport { logger } from '../utils-hoist/logger.js';\nimport { generateTraceId } from '../utils-hoist/propagationContext.js';\nimport { propagationContextFromHeaders } from '../utils-hoist/tracing.js';\nimport { getDynamicSamplingContextFromSpan, freezeDscOnSpan } from './dynamicSamplingContext.js';\nimport { logSpanStart } from './logSpans.js';\nimport { sampleSpan } from './sampling.js';\nimport { SentryNonRecordingSpan } from './sentryNonRecordingSpan.js';\nimport { SentrySpan } from './sentrySpan.js';\nimport { SPAN_STATUS_ERROR } from './spanstatus.js';\nimport { setCapturedScopesOnSpan } from './utils.js';\n\n/* eslint-disable max-lines */\n\n\nconst SUPPRESS_TRACING_KEY = '__SENTRY_SUPPRESS_TRACING__';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpan(options, callback) {\n  const acs = getAcs();\n  if (acs.startSpan) {\n    return acs.startSpan(options, callback);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan, scope: customScope } = options;\n\n  // We still need to fork a potentially passed scope, as we set the active span on it\n  // and we need to ensure that it is cleaned up properly once the span ends.\n  const customForkedScope = customScope?.clone();\n\n  return withScope(customForkedScope, () => {\n    // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n    const wrapper = getActiveSpanWrapper(customParentSpan);\n\n    return wrapper(() => {\n      const scope = getCurrentScope();\n      const parentSpan = getParentSpan(scope);\n\n      const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan\n        ? new SentryNonRecordingSpan()\n        : createChildOrRootSpan({\n            parentSpan,\n            spanArguments,\n            forceTransaction,\n            scope,\n          });\n\n      _setSpanForScope(scope, activeSpan);\n\n      return handleCallbackErrors(\n        () => callback(activeSpan),\n        () => {\n          // Only update the span status if it hasn't been changed yet, and the span is not yet finished\n          const { status } = spanToJSON(activeSpan);\n          if (activeSpan.isRecording() && (!status || status === 'ok')) {\n            activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n          }\n        },\n        () => {\n          activeSpan.end();\n        },\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a transaction/span, but does not finish the span\n * after the function is done automatically. Use `span.end()` to end the span.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpanManual(options, callback) {\n  const acs = getAcs();\n  if (acs.startSpanManual) {\n    return acs.startSpanManual(options, callback);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan, scope: customScope } = options;\n\n  const customForkedScope = customScope?.clone();\n\n  return withScope(customForkedScope, () => {\n    // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n    const wrapper = getActiveSpanWrapper(customParentSpan);\n\n    return wrapper(() => {\n      const scope = getCurrentScope();\n      const parentSpan = getParentSpan(scope);\n\n      const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan\n        ? new SentryNonRecordingSpan()\n        : createChildOrRootSpan({\n            parentSpan,\n            spanArguments,\n            forceTransaction,\n            scope,\n          });\n\n      _setSpanForScope(scope, activeSpan);\n\n      return handleCallbackErrors(\n        // We pass the `finish` function to the callback, so the user can finish the span manually\n        // this is mainly here for historic purposes because previously, we instructed users to call\n        // `finish` instead of `span.end()` to also clean up the scope. Nowadays, calling `span.end()`\n        // or `finish` has the same effect and we simply leave it here to avoid breaking user code.\n        () => callback(activeSpan, () => activeSpan.end()),\n        () => {\n          // Only update the span status if it hasn't been changed yet, and the span is not yet finished\n          const { status } = spanToJSON(activeSpan);\n          if (activeSpan.isRecording() && (!status || status === 'ok')) {\n            activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startInactiveSpan(options) {\n  const acs = getAcs();\n  if (acs.startInactiveSpan) {\n    return acs.startInactiveSpan(options);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan } = options;\n\n  // If `options.scope` is defined, we use this as as a wrapper,\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = options.scope\n    ? (callback) => withScope(options.scope, callback)\n    : customParentSpan !== undefined\n      ? (callback) => withActiveSpan(customParentSpan, callback)\n      : (callback) => callback();\n\n  return wrapper(() => {\n    const scope = getCurrentScope();\n    const parentSpan = getParentSpan(scope);\n\n    const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n\n    if (shouldSkipSpan) {\n      return new SentryNonRecordingSpan();\n    }\n\n    return createChildOrRootSpan({\n      parentSpan,\n      spanArguments,\n      forceTransaction,\n      scope,\n    });\n  });\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n */\nconst continueTrace = (\n  options\n\n,\n  callback,\n) => {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  if (acs.continueTrace) {\n    return acs.continueTrace(options, callback);\n  }\n\n  const { sentryTrace, baggage } = options;\n\n  return withScope(scope => {\n    const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n    scope.setPropagationContext(propagationContext);\n    return callback();\n  });\n};\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will not be attached to a parent span.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  const acs = getAcs();\n  if (acs.withActiveSpan) {\n    return acs.withActiveSpan(span, callback);\n  }\n\n  return withScope(scope => {\n    _setSpanForScope(scope, span || undefined);\n    return callback(scope);\n  });\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nfunction suppressTracing(callback) {\n  const acs = getAcs();\n\n  if (acs.suppressTracing) {\n    return acs.suppressTracing(callback);\n  }\n\n  return withScope(scope => {\n    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: true });\n    return callback();\n  });\n}\n\n/**\n * Starts a new trace for the duration of the provided callback. Spans started within the\n * callback will be part of the new trace instead of a potentially previously started trace.\n *\n * Important: Only use this function if you want to override the default trace lifetime and\n * propagation mechanism of the SDK for the duration and scope of the provided callback.\n * The newly created trace will also be the root of a new distributed trace, for example if\n * you make http requests within the callback.\n * This function might be useful if the operation you want to instrument should not be part\n * of a potentially ongoing trace.\n *\n * Default behavior:\n * - Server-side: A new trace is started for each incoming request.\n * - Browser: A new trace is started for each page our route. Navigating to a new route\n *            or page will automatically create a new trace.\n */\nfunction startNewTrace(callback) {\n  return withScope(scope => {\n    scope.setPropagationContext({\n      traceId: generateTraceId(),\n      sampleRand: Math.random(),\n    });\n    DEBUG_BUILD && logger.info(`Starting a new trace with id ${scope.getPropagationContext().traceId}`);\n    return withActiveSpan(null, callback);\n  });\n}\n\nfunction createChildOrRootSpan({\n  parentSpan,\n  spanArguments,\n  forceTransaction,\n  scope,\n}\n\n) {\n  if (!hasSpansEnabled()) {\n    const span = new SentryNonRecordingSpan();\n\n    // If this is a root span, we ensure to freeze a DSC\n    // So we can have at least partial data here\n    if (forceTransaction || !parentSpan) {\n      const dsc = {\n        sampled: 'false',\n        sample_rate: '0',\n        transaction: spanArguments.name,\n        ...getDynamicSamplingContextFromSpan(span),\n      } ;\n      freezeDscOnSpan(span, dsc);\n    }\n\n    return span;\n  }\n\n  const isolationScope = getIsolationScope();\n\n  let span;\n  if (parentSpan && !forceTransaction) {\n    span = _startChildSpan(parentSpan, scope, spanArguments);\n    addChildSpanToSpan(parentSpan, span);\n  } else if (parentSpan) {\n    // If we forced a transaction but have a parent span, make sure to continue from the parent span, not the scope\n    const dsc = getDynamicSamplingContextFromSpan(parentSpan);\n    const { traceId, spanId: parentSpanId } = parentSpan.spanContext();\n    const parentSampled = spanIsSampled(parentSpan);\n\n    span = _startRootSpan(\n      {\n        traceId,\n        parentSpanId,\n        ...spanArguments,\n      },\n      scope,\n      parentSampled,\n    );\n\n    freezeDscOnSpan(span, dsc);\n  } else {\n    const {\n      traceId,\n      dsc,\n      parentSpanId,\n      sampled: parentSampled,\n    } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext(),\n    };\n\n    span = _startRootSpan(\n      {\n        traceId,\n        parentSpanId,\n        ...spanArguments,\n      },\n      scope,\n      parentSampled,\n    );\n\n    if (dsc) {\n      freezeDscOnSpan(span, dsc);\n    }\n  }\n\n  logSpanStart(span);\n\n  setCapturedScopesOnSpan(span, scope, isolationScope);\n\n  return span;\n}\n\n/**\n * This converts StartSpanOptions to SentrySpanArguments.\n * For the most part (for now) we accept the same options,\n * but some of them need to be transformed.\n */\nfunction parseSentrySpanArguments(options) {\n  const exp = options.experimental || {};\n  const initialCtx = {\n    isStandalone: exp.standalone,\n    ...options,\n  };\n\n  if (options.startTime) {\n    const ctx = { ...initialCtx };\n    ctx.startTimestamp = spanTimeInputToSeconds(options.startTime);\n    delete ctx.startTime;\n    return ctx;\n  }\n\n  return initialCtx;\n}\n\nfunction getAcs() {\n  const carrier = getMainCarrier();\n  return getAsyncContextStrategy(carrier);\n}\n\nfunction _startRootSpan(spanArguments, scope, parentSampled) {\n  const client = getClient();\n  const options = client?.getOptions() || {};\n\n  const { name = '' } = spanArguments;\n\n  const mutableSpanSamplingData = { spanAttributes: { ...spanArguments.attributes }, spanName: name, parentSampled };\n\n  // we don't care about the decision for the moment; this is just a placeholder\n  client?.emit('beforeSampling', mutableSpanSamplingData, { decision: false });\n\n  // If hook consumers override the parentSampled flag, we will use that value instead of the actual one\n  const finalParentSampled = mutableSpanSamplingData.parentSampled ?? parentSampled;\n  const finalAttributes = mutableSpanSamplingData.spanAttributes;\n\n  const currentPropagationContext = scope.getPropagationContext();\n  const [sampled, sampleRate, localSampleRateWasApplied] = scope.getScopeData().sdkProcessingMetadata[\n    SUPPRESS_TRACING_KEY\n  ]\n    ? [false]\n    : sampleSpan(\n        options,\n        {\n          name,\n          parentSampled: finalParentSampled,\n          attributes: finalAttributes,\n          parentSampleRate: parseSampleRate(currentPropagationContext.dsc?.sample_rate),\n        },\n        currentPropagationContext.sampleRand,\n      );\n\n  const rootSpan = new SentrySpan({\n    ...spanArguments,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'custom',\n      [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]:\n        sampleRate !== undefined && localSampleRateWasApplied ? sampleRate : undefined,\n      ...finalAttributes,\n    },\n    sampled,\n  });\n\n  if (!sampled && client) {\n    DEBUG_BUILD && logger.log('[Tracing] Discarding root span because its trace was not chosen to be sampled.');\n    client.recordDroppedEvent('sample_rate', 'transaction');\n  }\n\n  if (client) {\n    client.emit('spanStart', rootSpan);\n  }\n\n  return rootSpan;\n}\n\n/**\n * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.\n * This inherits the sampling decision from the parent span.\n */\nfunction _startChildSpan(parentSpan, scope, spanArguments) {\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? false : spanIsSampled(parentSpan);\n\n  const childSpan = sampled\n    ? new SentrySpan({\n        ...spanArguments,\n        parentSpanId: spanId,\n        traceId,\n        sampled,\n      })\n    : new SentryNonRecordingSpan({ traceId });\n\n  addChildSpanToSpan(parentSpan, childSpan);\n\n  const client = getClient();\n  if (client) {\n    client.emit('spanStart', childSpan);\n    // If it has an endTimestamp, it's already ended\n    if (spanArguments.endTimestamp) {\n      client.emit('spanEnd', childSpan);\n    }\n  }\n\n  return childSpan;\n}\n\nfunction getParentSpan(scope) {\n  const span = _getSpanForScope(scope) ;\n\n  if (!span) {\n    return undefined;\n  }\n\n  const client = getClient();\n  const options = client ? client.getOptions() : {};\n  if (options.parentSpanIsAlwaysRootSpan) {\n    return getRootSpan(span) ;\n  }\n\n  return span;\n}\n\nfunction getActiveSpanWrapper(parentSpan) {\n  return parentSpan !== undefined\n    ? (callback) => {\n        return withActiveSpan(parentSpan, callback);\n      }\n    : (callback) => callback();\n}\n\nexport { continueTrace, startInactiveSpan, startNewTrace, startSpan, startSpanManual, suppressTracing, withActiveSpan };\n//# sourceMappingURL=trace.js.map\n"],"names":["SUPPRESS_TRACING_KEY","startInactiveSpan","options","acs","getAcs","spanArguments","parseSentrySpanArguments","forceTransaction","customParentSpan","callback","withScope","withActiveSpan","scope","getCurrentScope","parentSpan","getParentSpan","SentryNonRecordingSpan","createChildOrRootSpan","span","_setSpanForScope","hasSpansEnabled","dsc","getDynamicSamplingContextFromSpan","freezeDscOnSpan","isolationScope","getIsolationScope","_startChildSpan","addChildSpanToSpan","traceId","parentSpanId","parentSampled","spanIsSampled","_startRootSpan","logSpanStart","setCapturedScopesOnSpan","initialCtx","ctx","spanTimeInputToSeconds","carrier","getMainCarrier","getAsyncContextStrategy","client","getClient","name","mutableSpanSamplingData","finalParentSampled","finalAttributes","currentPropagationContext","sampled","sampleRate","localSampleRateWasApplied","sampleSpan","parseSampleRate","rootSpan","SentrySpan","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE","DEBUG_BUILD","logger","spanId","childSpan","_getSpanForScope","getRootSpan"],"mappings":"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","x_google_ignoreList":[0]}