{"version":3,"file":"sampling.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/tracing/sampling.js"],"sourcesContent":["import { DEBUG_BUILD } from '../debug-build.js';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled.js';\nimport { parseSampleRate } from '../utils/parseSampleRate.js';\nimport { logger } from '../utils-hoist/logger.js';\n\n/**\n * Makes a sampling decision for the given options.\n *\n * Called every time a root span is created. Only root spans which emerge with a `sampled` value of `true` will be\n * sent to Sentry.\n */\nfunction sampleSpan(\n  options,\n  samplingContext,\n  sampleRand,\n) {\n  // nothing to do if span recording is not enabled\n  if (!hasSpansEnabled(options)) {\n    return [false];\n  }\n\n  let localSampleRateWasApplied = undefined;\n\n  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should\n  // work; prefer the hook if so\n  let sampleRate;\n  if (typeof options.tracesSampler === 'function') {\n    sampleRate = options.tracesSampler({\n      ...samplingContext,\n      inheritOrSampleWith: fallbackSampleRate => {\n        // If we have an incoming parent sample rate, we'll just use that one.\n        // The sampling decision will be inherited because of the sample_rand that was generated when the trace reached the incoming boundaries of the SDK.\n        if (typeof samplingContext.parentSampleRate === 'number') {\n          return samplingContext.parentSampleRate;\n        }\n\n        // Fallback if parent sample rate is not on the incoming trace (e.g. if there is no baggage)\n        // This is to provide backwards compatibility if there are incoming traces from older SDKs that don't send a parent sample rate or a sample rand. In these cases we just want to force either a sampling decision on the downstream traces via the sample rate.\n        if (typeof samplingContext.parentSampled === 'boolean') {\n          return Number(samplingContext.parentSampled);\n        }\n\n        return fallbackSampleRate;\n      },\n    });\n    localSampleRateWasApplied = true;\n  } else if (samplingContext.parentSampled !== undefined) {\n    sampleRate = samplingContext.parentSampled;\n  } else if (typeof options.tracesSampleRate !== 'undefined') {\n    sampleRate = options.tracesSampleRate;\n    localSampleRateWasApplied = true;\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get.\n  // (The only valid values are booleans or numbers between 0 and 1.)\n  const parsedSampleRate = parseSampleRate(sampleRate);\n\n  if (parsedSampleRate === undefined) {\n    DEBUG_BUILD &&\n      logger.warn(\n        `[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          sampleRate,\n        )} of type ${JSON.stringify(typeof sampleRate)}.`,\n      );\n    return [false];\n  }\n\n  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped\n  if (!parsedSampleRate) {\n    DEBUG_BUILD &&\n      logger.log(\n        `[Tracing] Discarding transaction because ${\n          typeof options.tracesSampler === 'function'\n            ? 'tracesSampler returned 0 or false'\n            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'\n        }`,\n      );\n    return [false, parsedSampleRate, localSampleRateWasApplied];\n  }\n\n  // We always compare the sample rand for the current execution context against the chosen sample rate.\n  // Read more: https://develop.sentry.dev/sdk/telemetry/traces/#propagated-random-value\n  const shouldSample = sampleRand < parsedSampleRate;\n\n  // if we're not going to keep it, we're done\n  if (!shouldSample) {\n    DEBUG_BUILD &&\n      logger.log(\n        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(\n          sampleRate,\n        )})`,\n      );\n  }\n\n  return [shouldSample, parsedSampleRate, localSampleRateWasApplied];\n}\n\nexport { sampleSpan };\n//# sourceMappingURL=sampling.js.map\n"],"names":["sampleSpan","options","samplingContext","sampleRand","hasSpansEnabled","localSampleRateWasApplied","sampleRate","fallbackSampleRate","parsedSampleRate","parseSampleRate","DEBUG_BUILD","logger","shouldSample"],"mappings":"8NAWA,SAASA,EACPC,EACAC,EACAC,EACA,CAEA,GAAI,CAACC,EAAgBH,CAAO,EAC1B,MAAO,CAAC,EAAK,EAGf,IAAII,EAIAC,EACA,OAAOL,EAAQ,eAAkB,YACnCK,EAAaL,EAAQ,cAAc,CACjC,GAAGC,EACH,oBAAqBK,GAGf,OAAOL,EAAgB,kBAAqB,SACvCA,EAAgB,iBAKrB,OAAOA,EAAgB,eAAkB,UACpC,OAAOA,EAAgB,aAAa,EAGtCK,CAEf,CAAK,EACDF,EAA4B,IACnBH,EAAgB,gBAAkB,OAC3CI,EAAaJ,EAAgB,cACpB,OAAOD,EAAQ,iBAAqB,MAC7CK,EAAaL,EAAQ,iBACrBI,EAA4B,IAK9B,MAAMG,EAAmBC,EAAgBH,CAAU,EAEnD,GAAIE,IAAqB,OACvB,OAAAE,GACEC,EAAO,KACL,iIAAiI,KAAK,UACpIL,CACV,CAAS,YAAY,KAAK,UAAU,OAAOA,CAAU,CAAC,GAC/C,EACI,CAAC,EAAK,EAIf,GAAI,CAACE,EACH,OAAAE,GACEC,EAAO,IACL,4CACE,OAAOV,EAAQ,eAAkB,WAC7B,oCACA,4EACd,EACO,EACI,CAAC,GAAOO,EAAkBH,CAAyB,EAK5D,MAAMO,EAAeT,EAAaK,EAGlC,OAAKI,GACHF,GACEC,EAAO,IACL,oGAAoG,OAClGL,CACD,CAAA,GACF,EAGE,CAACM,EAAcJ,EAAkBH,CAAyB,CACnE","x_google_ignoreList":[0]}