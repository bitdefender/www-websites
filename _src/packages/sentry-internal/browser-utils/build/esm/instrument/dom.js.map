{"version":3,"file":"dom.js","sources":["../../../../../../../node_modules/@sentry-internal/browser-utils/build/esm/instrument/dom.js"],"sourcesContent":["import { addHandler, maybeInstrument, triggerHandlers, fill, addNonEnumerableProperty, uuid4 } from '@sentry/core';\nimport { WINDOW } from '../types.js';\n\nconst DEBOUNCE_DURATION = 1000;\n\nlet debounceTimerID;\nlet lastCapturedEventType;\nlet lastCapturedEventTargetId;\n\n/**\n * Add an instrumentation handler for when a click or a keypress happens.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addClickKeypressInstrumentationHandler(handler) {\n  const type = 'dom';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentDOM);\n}\n\n/** Exported for tests only. */\nfunction instrumentDOM() {\n  if (!WINDOW.document) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target) => {\n    const globalObject = WINDOW ;\n    const proto = globalObject[target]?.prototype;\n\n    // eslint-disable-next-line no-prototype-builtins\n    if (!proto?.hasOwnProperty?.('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener) {\n      return function ( type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const handlers = (this.__sentry_instrumentation_handlers__ =\n              this.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount++;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener) {\n        return function ( type, listener, options) {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const handlers = this.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount--;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete this.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\n/**\n * Check whether the event is similar to the last captured one. For example, two click events on the same button.\n */\nfunction isSimilarToLastCapturedEvent(event) {\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (event.type !== lastCapturedEventType) {\n    return false;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (!event.target || (event.target )._sentryId !== lastCapturedEventTargetId) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return true;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(eventType, target) {\n  // We are only interested in filtering `keypress` events for now.\n  if (eventType !== 'keypress') {\n    return false;\n  }\n\n  if (!target?.tagName) {\n    return true;\n  }\n\n  // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n  // e.g.tabbing through elements, hotkeys, etc.\n  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n */\nfunction makeDOMEventHandler(\n  handler,\n  globalListener = false,\n) {\n  return (event) => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || event['_sentryCaptured']) {\n      return;\n    }\n\n    const target = getEventTarget(event);\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event.type, target)) {\n      return;\n    }\n\n    // Mark event as \"seen\"\n    addNonEnumerableProperty(event, '_sentryCaptured', true);\n\n    if (target && !target._sentryId) {\n      // Add UUID to event target so we can identify if\n      addNonEnumerableProperty(target, '_sentryId', uuid4());\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no last captured event, it means that we can safely capture the new event and store it for future comparisons.\n    // If there is a last captured event, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    if (!isSimilarToLastCapturedEvent(event)) {\n      const handlerData = { event, name, global: globalListener };\n      handler(handlerData);\n      lastCapturedEventType = event.type;\n      lastCapturedEventTargetId = target ? target._sentryId : undefined;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(() => {\n      lastCapturedEventTargetId = undefined;\n      lastCapturedEventType = undefined;\n    }, DEBOUNCE_DURATION);\n  };\n}\n\nfunction getEventTarget(event) {\n  try {\n    return event.target ;\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n    return null;\n  }\n}\n\nexport { addClickKeypressInstrumentationHandler, instrumentDOM };\n//# sourceMappingURL=dom.js.map\n"],"names":["DEBOUNCE_DURATION","debounceTimerID","lastCapturedEventType","lastCapturedEventTargetId","addClickKeypressInstrumentationHandler","handler","type","addHandler","maybeInstrument","instrumentDOM","WINDOW","triggerDOMHandler","triggerHandlers","globalDOMEventHandler","makeDOMEventHandler","target","proto","fill","originalAddEventListener","listener","options","handlers","handlerForType","originalRemoveEventListener","isSimilarToLastCapturedEvent","event","shouldSkipDOMEvent","eventType","globalListener","getEventTarget","addNonEnumerableProperty","uuid4","name"],"mappings":"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","x_google_ignoreList":[0]}