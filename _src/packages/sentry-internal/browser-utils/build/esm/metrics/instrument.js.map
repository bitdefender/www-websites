{"version":3,"file":"instrument.js","sources":["../../../../../../../node_modules/@sentry-internal/browser-utils/build/esm/metrics/instrument.js"],"sourcesContent":["import { logger, getFunctionName } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { onCLS } from './web-vitals/getCLS.js';\nimport { onFID } from './web-vitals/getFID.js';\nimport { onINP } from './web-vitals/getINP.js';\nimport { onLCP } from './web-vitals/getLCP.js';\nimport { observe } from './web-vitals/lib/observe.js';\nimport { onTTFB } from './web-vitals/onTTFB.js';\n\nconst handlers = {};\nconst instrumented = {};\n\nlet _previousCls;\nlet _previousFid;\nlet _previousLcp;\nlet _previousTtfb;\nlet _previousInp;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for CLS when the cleanup callback is called.\n * This will lead to the CLS being finalized and frozen.\n */\nfunction addClsInstrumentationHandler(\n  callback,\n  stopOnCallback = false,\n) {\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for LCP when the cleanup callback is called.\n * This will lead to the LCP being finalized and frozen.\n */\nfunction addLcpInstrumentationHandler(\n  callback,\n  stopOnCallback = false,\n) {\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addFidInstrumentationHandler(callback) {\n  return addMetricObserver('fid', callback, instrumentFid, _previousFid);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n */\nfunction addTtfbInstrumentationHandler(callback) {\n  return addMetricObserver('ttfb', callback, instrumentTtfb, _previousTtfb);\n}\n\n/**\n * Add a callback that will be triggered when a INP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addInpInstrumentationHandler(\n  callback,\n) {\n  return addMetricObserver('inp', callback, instrumentInp, _previousInp);\n}\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addPerformanceInstrumentationHandler(\n  type,\n  callback,\n) {\n  addHandler(type, callback);\n\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type, data) {\n  const typeHandlers = handlers[type];\n\n  if (!typeHandlers?.length) {\n    return;\n  }\n\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\nfunction instrumentCls() {\n  return onCLS(\n    metric => {\n      triggerHandlers('cls', {\n        metric,\n      });\n      _previousCls = metric;\n    },\n    // We want the callback to be called whenever the CLS value updates.\n    // By default, the callback is only called when the tab goes to the background.\n    { reportAllChanges: true },\n  );\n}\n\nfunction instrumentFid() {\n  return onFID(metric => {\n    triggerHandlers('fid', {\n      metric,\n    });\n    _previousFid = metric;\n  });\n}\n\nfunction instrumentLcp() {\n  return onLCP(\n    metric => {\n      triggerHandlers('lcp', {\n        metric,\n      });\n      _previousLcp = metric;\n    },\n    // We want the callback to be called whenever the LCP value updates.\n    // By default, the callback is only called when the tab goes to the background.\n    { reportAllChanges: true },\n  );\n}\n\nfunction instrumentTtfb() {\n  return onTTFB(metric => {\n    triggerHandlers('ttfb', {\n      metric,\n    });\n    _previousTtfb = metric;\n  });\n}\n\nfunction instrumentInp() {\n  return onINP(metric => {\n    triggerHandlers('inp', {\n      metric,\n    });\n    _previousInp = metric;\n  });\n}\n\nfunction addMetricObserver(\n  type,\n  callback,\n  instrumentFn,\n  previousValue,\n  stopOnCallback = false,\n) {\n  addHandler(type, callback);\n\n  let stopListening;\n\n  if (!instrumented[type]) {\n    stopListening = instrumentFn();\n    instrumented[type] = true;\n  }\n\n  if (previousValue) {\n    callback({ metric: previousValue });\n  }\n\n  return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);\n}\n\nfunction instrumentPerformanceObserver(type) {\n  const options = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n\n  observe(\n    type,\n    entries => {\n      triggerHandlers(type, { entries });\n    },\n    options,\n  );\n}\n\nfunction addHandler(type, handler) {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] ).push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(\n  type,\n  callback,\n  stopListening,\n) {\n  return () => {\n    if (stopListening) {\n      stopListening();\n    }\n\n    const typeHandlers = handlers[type];\n\n    if (!typeHandlers) {\n      return;\n    }\n\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\n\n/**\n * Check if a PerformanceEntry is a PerformanceEventTiming by checking for the `duration` property.\n */\nfunction isPerformanceEventTiming(entry) {\n  return 'duration' in entry;\n}\n\nexport { addClsInstrumentationHandler, addFidInstrumentationHandler, addInpInstrumentationHandler, addLcpInstrumentationHandler, addPerformanceInstrumentationHandler, addTtfbInstrumentationHandler, isPerformanceEventTiming };\n//# sourceMappingURL=instrument.js.map\n"],"names":["handlers","instrumented","_previousCls","_previousFid","_previousLcp","_previousTtfb","_previousInp","addClsInstrumentationHandler","callback","stopOnCallback","addMetricObserver","instrumentCls","addLcpInstrumentationHandler","instrumentLcp","addFidInstrumentationHandler","instrumentFid","addTtfbInstrumentationHandler","instrumentTtfb","addInpInstrumentationHandler","instrumentInp","addPerformanceInstrumentationHandler","type","addHandler","instrumentPerformanceObserver","getCleanupCallback","triggerHandlers","data","typeHandlers","handler","e","DEBUG_BUILD","logger","getFunctionName","onCLS","metric","onFID","onLCP","onTTFB","onINP","instrumentFn","previousValue","stopListening","options","observe","entries","index","isPerformanceEventTiming","entry"],"mappings":"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","x_google_ignoreList":[0]}