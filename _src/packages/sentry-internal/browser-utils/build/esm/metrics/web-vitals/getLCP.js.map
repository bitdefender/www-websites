{"version":3,"file":"getLCP.js","sources":["../../../../../../../../node_modules/@sentry-internal/browser-utils/build/esm/metrics/web-vitals/getLCP.js"],"sourcesContent":["import { WINDOW } from '../../types.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { getActivationStart } from './lib/getActivationStart.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\nimport { runOnce } from './lib/runOnce.js';\nimport { whenActivated } from './lib/whenActivated.js';\nimport { whenIdle } from './lib/whenIdle.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** Thresholds for LCP. See https://web.dev/articles/lcp#what_is_a_good_lcp_score */\nconst LCPThresholds = [2500, 4000];\n\nconst reportedMetricIDs = {};\n\n/**\n * Calculates the [LCP](https://web.dev/articles/lcp) value for the current page and\n * calls the `callback` function once the value is ready (along with the\n * relevant `largest-contentful-paint` performance entry used to determine the\n * value). The reported value is a `DOMHighResTimeStamp`.\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called any time a new `largest-contentful-paint`\n * performance entry is dispatched, or once the final value of the metric has\n * been determined.\n */\nconst onLCP = (onReport, opts = {}) => {\n  whenActivated(() => {\n    const visibilityWatcher = getVisibilityWatcher();\n    const metric = initMetric('LCP');\n    let report;\n\n    const handleEntries = (entries) => {\n      // If reportAllChanges is set then call this function for each entry,\n      // otherwise only consider the last one.\n      if (!opts.reportAllChanges) {\n        // eslint-disable-next-line no-param-reassign\n        entries = entries.slice(-1);\n      }\n\n      entries.forEach(entry => {\n        // Only report if the page wasn't hidden prior to LCP.\n        if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n          // The startTime attribute returns the value of the renderTime if it is\n          // not 0, and the value of the loadTime otherwise. The activationStart\n          // reference is used because LCP should be relative to page activation\n          // rather than navigation start if the page was pre-rendered. But in cases\n          // where `activationStart` occurs after the LCP, this time should be\n          // clamped at 0.\n          metric.value = Math.max(entry.startTime - getActivationStart(), 0);\n          metric.entries = [entry];\n          report();\n        }\n      });\n    };\n\n    const po = observe('largest-contentful-paint', handleEntries);\n\n    if (po) {\n      report = bindReporter(onReport, metric, LCPThresholds, opts.reportAllChanges);\n\n      const stopListening = runOnce(() => {\n        if (!reportedMetricIDs[metric.id]) {\n          handleEntries(po.takeRecords() );\n          po.disconnect();\n          reportedMetricIDs[metric.id] = true;\n          report(true);\n        }\n      });\n\n      // Stop listening after input. Note: while scrolling is an input that\n      // stops LCP observation, it's unreliable since it can be programmatically\n      // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75\n      ['keydown', 'click'].forEach(type => {\n        // Wrap in a setTimeout so the callback is run in a separate task\n        // to avoid extending the keyboard/click handler to reduce INP impact\n        // https://github.com/GoogleChrome/web-vitals/issues/383\n        if (WINDOW.document) {\n          addEventListener(type, () => whenIdle(stopListening ), {\n            once: true,\n            capture: true,\n          });\n        }\n      });\n\n      onHidden(stopListening);\n    }\n  });\n};\n\nexport { LCPThresholds, onLCP };\n//# sourceMappingURL=getLCP.js.map\n"],"names":["LCPThresholds","reportedMetricIDs","onLCP","onReport","opts","whenActivated","visibilityWatcher","getVisibilityWatcher","metric","initMetric","report","handleEntries","entries","entry","getActivationStart","po","observe","bindReporter","stopListening","runOnce","type","WINDOW","whenIdle","onHidden"],"mappings":"2fA6BK,MAACA,EAAgB,CAAC,KAAM,GAAI,EAE3BC,EAAoB,CAAE,EAatBC,EAAQ,CAACC,EAAUC,EAAO,KAAO,CACrCC,EAAc,IAAM,CAClB,MAAMC,EAAoBC,EAAsB,EAC1CC,EAASC,EAAW,KAAK,EAC/B,IAAIC,EAEJ,MAAMC,EAAiBC,GAAY,CAG5BR,EAAK,mBAERQ,EAAUA,EAAQ,MAAM,EAAE,GAG5BA,EAAQ,QAAQC,GAAS,CAEnBA,EAAM,UAAYP,EAAkB,kBAOtCE,EAAO,MAAQ,KAAK,IAAIK,EAAM,UAAYC,EAAoB,EAAE,CAAC,EACjEN,EAAO,QAAU,CAACK,CAAK,EACvBH,EAAQ,EAElB,CAAO,CACF,EAEKK,EAAKC,EAAQ,2BAA4BL,CAAa,EAE5D,GAAII,EAAI,CACNL,EAASO,EAAad,EAAUK,EAAQR,EAAeI,EAAK,gBAAgB,EAE5E,MAAMc,EAAgBC,EAAQ,IAAM,CAC7BlB,EAAkBO,EAAO,EAAE,IAC9BG,EAAcI,EAAG,aAAe,EAChCA,EAAG,WAAY,EACfd,EAAkBO,EAAO,EAAE,EAAI,GAC/BE,EAAO,EAAI,EAErB,CAAO,EAKD,CAAC,UAAW,OAAO,EAAE,QAAQU,GAAQ,CAI/BC,EAAO,UACT,iBAAiBD,EAAM,IAAME,EAASJ,CAAa,EAAI,CACrD,KAAM,GACN,QAAS,EACrB,CAAW,CAEX,CAAO,EAEDK,EAASL,CAAa,CAC5B,CACA,CAAG,CACH","x_google_ignoreList":[0]}