{"version":3,"file":"browserMetrics.js","sources":["../../../../../../../node_modules/@sentry-internal/browser-utils/build/esm/metrics/browserMetrics.js"],"sourcesContent":["import { browserPerformanceTimeOrigin, spanToJSON, setMeasurement, getActiveSpan, parseUrl, isPrimitive, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, htmlTreeAsString, getComponentName } from '@sentry/core';\nimport { WINDOW } from '../types.js';\nimport { trackClsAsStandaloneSpan } from './cls.js';\nimport { addPerformanceInstrumentationHandler, addFidInstrumentationHandler, addLcpInstrumentationHandler, addTtfbInstrumentationHandler, addClsInstrumentationHandler } from './instrument.js';\nimport { getBrowserPerformanceAPI, msToSec, startAndEndSpan, extractNetworkProtocol, isMeasurementValue } from './utils.js';\nimport { getActivationStart } from './web-vitals/lib/getActivationStart.js';\nimport { getNavigationEntry } from './web-vitals/lib/getNavigationEntry.js';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher.js';\n\nconst MAX_INT_AS_BYTES = 2147483647;\n\nlet _performanceCursor = 0;\n\nlet _measurements = {};\nlet _lcpEntry;\nlet _clsEntry;\n\n/**\n * Start tracking web vitals.\n * The callback returned by this function can be used to stop tracking & ensure all measurements are final & captured.\n *\n * @returns A function that forces web vitals collection\n */\nfunction startTrackingWebVitals({ recordClsStandaloneSpans }) {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin()) {\n    // @ts-expect-error we want to make sure all of these are available, even if TS is sure they are\n    if (performance.mark) {\n      WINDOW.performance.mark('sentry-tracing-init');\n    }\n    const fidCleanupCallback = _trackFID();\n    const lcpCleanupCallback = _trackLCP();\n    const ttfbCleanupCallback = _trackTtfb();\n    const clsCleanupCallback = recordClsStandaloneSpans ? trackClsAsStandaloneSpan() : _trackCLS();\n\n    return () => {\n      fidCleanupCallback();\n      lcpCleanupCallback();\n      ttfbCleanupCallback();\n      clsCleanupCallback?.();\n    };\n  }\n\n  return () => undefined;\n}\n\n/**\n * Start tracking long tasks.\n */\nfunction startTrackingLongTasks() {\n  addPerformanceInstrumentationHandler('longtask', ({ entries }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n\n    const { op: parentOp, start_timestamp: parentStartTimestamp } = spanToJSON(parent);\n\n    for (const entry of entries) {\n      const startTime = msToSec((browserPerformanceTimeOrigin() ) + entry.startTime);\n      const duration = msToSec(entry.duration);\n\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding a span if the long task started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-task',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n        },\n      });\n    }\n  });\n}\n\n/**\n * Start tracking long animation frames.\n */\nfunction startTrackingLongAnimationFrames() {\n  // NOTE: the current web-vitals version (3.5.2) does not support long-animation-frame, so\n  // we directly observe `long-animation-frame` events instead of through the web-vitals\n  // `observe` helper function.\n  const observer = new PerformanceObserver(list => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of list.getEntries() ) {\n      if (!entry.scripts[0]) {\n        continue;\n      }\n\n      const startTime = msToSec((browserPerformanceTimeOrigin() ) + entry.startTime);\n\n      const { start_timestamp: parentStartTimestamp, op: parentOp } = spanToJSON(parent);\n\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding the span if the long animation frame started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n      const duration = msToSec(entry.duration);\n\n      const attributes = {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      };\n\n      const initialScript = entry.scripts[0];\n      const { invoker, invokerType, sourceURL, sourceFunctionName, sourceCharPosition } = initialScript;\n      attributes['browser.script.invoker'] = invoker;\n      attributes['browser.script.invoker_type'] = invokerType;\n      if (sourceURL) {\n        attributes['code.filepath'] = sourceURL;\n      }\n      if (sourceFunctionName) {\n        attributes['code.function'] = sourceFunctionName;\n      }\n      if (sourceCharPosition !== -1) {\n        attributes['browser.script.source_char_position'] = sourceCharPosition;\n      }\n\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-animation-frame',\n        attributes,\n      });\n    }\n  });\n\n  observer.observe({ type: 'long-animation-frame', buffered: true });\n}\n\n/**\n * Start tracking interaction events.\n */\nfunction startTrackingInteractions() {\n  addPerformanceInstrumentationHandler('event', ({ entries }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of entries) {\n      if (entry.name === 'click') {\n        const startTime = msToSec((browserPerformanceTimeOrigin() ) + entry.startTime);\n        const duration = msToSec(entry.duration);\n\n        const spanOptions = {\n          name: htmlTreeAsString(entry.target),\n          op: `ui.interaction.${entry.name}`,\n          startTime: startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n          },\n        };\n\n        const componentName = getComponentName(entry.target);\n        if (componentName) {\n          spanOptions.attributes['ui.component_name'] = componentName;\n        }\n\n        startAndEndSpan(parent, startTime, startTime + duration, spanOptions);\n      }\n    }\n  });\n}\n\n/**\n * Starts tracking the Cumulative Layout Shift on the current page and collects the value and last entry\n * to the `_measurements` object which ultimately is applied to the pageload span's measurements.\n */\nfunction _trackCLS() {\n  return addClsInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1] ;\n    if (!entry) {\n      return;\n    }\n    _measurements['cls'] = { value: metric.value, unit: '' };\n    _clsEntry = entry;\n  }, true);\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP() {\n  return addLcpInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    _measurements['lcp'] = { value: metric.value, unit: 'millisecond' };\n    _lcpEntry = entry ;\n  }, true);\n}\n\n/** Starts tracking the First Input Delay on the current page. */\nfunction _trackFID() {\n  return addFidInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin() );\n    const startTime = msToSec(entry.startTime);\n    _measurements['fid'] = { value: metric.value, unit: 'millisecond' };\n    _measurements['mark.fid'] = { value: timeOrigin + startTime, unit: 'second' };\n  });\n}\n\nfunction _trackTtfb() {\n  return addTtfbInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    _measurements['ttfb'] = { value: metric.value, unit: 'millisecond' };\n  });\n}\n\n/** Add performance related spans to a transaction */\nfunction addPerformanceEntries(span, options) {\n  const performance = getBrowserPerformanceAPI();\n  const origin = browserPerformanceTimeOrigin();\n  if (!performance?.getEntries || !origin) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n\n  const timeOrigin = msToSec(origin);\n\n  const performanceEntries = performance.getEntries();\n\n  const { op, start_timestamp: transactionStartTime } = spanToJSON(span);\n\n  performanceEntries.slice(_performanceCursor).forEach(entry => {\n    const startTime = msToSec(entry.startTime);\n    const duration = msToSec(\n      // Inexplicably, Chrome sometimes emits a negative duration. We need to work around this.\n      // There is a SO post attempting to explain this, but it leaves one with open questions: https://stackoverflow.com/questions/23191918/peformance-getentries-and-negative-duration-display\n      // The way we clamp the value is probably not accurate, since we have observed this happen for things that may take a while to load, like for example the replay worker.\n      // TODO: Investigate why this happens and how to properly mitigate. For now, this is a workaround to prevent transactions being dropped due to negative duration spans.\n      Math.max(0, entry.duration),\n    );\n\n    if (op === 'navigation' && transactionStartTime && timeOrigin + startTime < transactionStartTime) {\n      return;\n    }\n\n    switch (entry.entryType) {\n      case 'navigation': {\n        _addNavigationSpans(span, entry , timeOrigin);\n        break;\n      }\n      case 'mark':\n      case 'paint':\n      case 'measure': {\n        _addMeasureSpans(span, entry , startTime, duration, timeOrigin);\n\n        // capture web vitals\n        const firstHidden = getVisibilityWatcher();\n        // Only report if the page wasn't hidden prior to the web vital.\n        const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n        if (entry.name === 'first-paint' && shouldRecord) {\n          _measurements['fp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        if (entry.name === 'first-contentful-paint' && shouldRecord) {\n          _measurements['fcp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        break;\n      }\n      case 'resource': {\n        _addResourceSpans(span, entry , entry.name, startTime, duration, timeOrigin);\n        break;\n      }\n      // Ignore other entry types.\n    }\n  });\n\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n\n  _trackNavigator(span);\n\n  // Measurements are only available for pageload transactions\n  if (op === 'pageload') {\n    _addTtfbRequestTimeToMeasurements(_measurements);\n\n    const fidMark = _measurements['mark.fid'];\n    if (fidMark && _measurements['fid']) {\n      // create span for FID\n      startAndEndSpan(span, fidMark.value, fidMark.value + msToSec(_measurements['fid'].value), {\n        name: 'first input delay',\n        op: 'ui.action',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n        },\n      });\n\n      // Delete mark.fid as we don't want it to be part of final payload\n      delete _measurements['mark.fid'];\n    }\n\n    // If FCP is not recorded we should not record the cls value\n    // according to the new definition of CLS.\n    // TODO: Check if the first condition is still necessary: `onCLS` already only fires once `onFCP` was called.\n    if (!('fcp' in _measurements) || !options.recordClsOnPageloadSpan) {\n      delete _measurements.cls;\n    }\n\n    Object.entries(_measurements).forEach(([measurementName, measurement]) => {\n      setMeasurement(measurementName, measurement.value, measurement.unit);\n    });\n\n    // Set timeOrigin which denotes the timestamp which to base the LCP/FCP/FP/TTFB measurements on\n    span.setAttribute('performance.timeOrigin', timeOrigin);\n\n    // In prerendering scenarios, where a page might be prefetched and pre-rendered before the user clicks the link,\n    // the navigation starts earlier than when the user clicks it. Web Vitals should always be based on the\n    // user-perceived time, so they are not reported from the actual start of the navigation, but rather from the\n    // time where the user actively started the navigation, for example by clicking a link.\n    // This is user action is called \"activation\" and the time between navigation and activation is stored in\n    // the `activationStart` attribute of the \"navigation\" PerformanceEntry.\n    span.setAttribute('performance.activationStart', getActivationStart());\n\n    _setWebVitalAttributes(span);\n  }\n\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/**\n * Create measure related spans.\n * Exported only for tests.\n */\nfunction _addMeasureSpans(\n  span,\n  entry,\n  startTime,\n  duration,\n  timeOrigin,\n) {\n  const navEntry = getNavigationEntry(false);\n  const requestTime = msToSec(navEntry ? navEntry.requestStart : 0);\n  // Because performance.measure accepts arbitrary timestamps it can produce\n  // spans that happen before the browser even makes a request for the page.\n  //\n  // An example of this is the automatically generated Next.js-before-hydration\n  // spans created by the Next.js framework.\n  //\n  // To prevent this we will pin the start timestamp to the request start time\n  // This does make duration inaccurate, so if this does happen, we will add\n  // an attribute to the span\n  const measureStartTimestamp = timeOrigin + Math.max(startTime, requestTime);\n  const startTimeStamp = timeOrigin + startTime;\n  const measureEndTimestamp = startTimeStamp + duration;\n\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics',\n  };\n\n  if (measureStartTimestamp !== startTimeStamp) {\n    attributes['sentry.browser.measure_happened_before_request'] = true;\n    attributes['sentry.browser.measure_start_time'] = measureStartTimestamp;\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure#detail\n  if (entry.detail) {\n    // Handle detail as an object\n    if (typeof entry.detail === 'object') {\n      for (const [key, value] of Object.entries(entry.detail)) {\n        if (value && isPrimitive(value)) {\n          attributes[`sentry.browser.measure.detail.${key}`] = value ;\n        } else {\n          try {\n            // This is user defined so we can't guarantee it's serializable\n            attributes[`sentry.browser.measure.detail.${key}`] = JSON.stringify(value);\n          } catch {\n            // skip\n          }\n        }\n      }\n    } else if (isPrimitive(entry.detail)) {\n      attributes['sentry.browser.measure.detail'] = entry.detail ;\n    } else {\n      // This is user defined so we can't guarantee it's serializable\n      try {\n        attributes['sentry.browser.measure.detail'] = JSON.stringify(entry.detail);\n      } catch {\n        // skip\n      }\n    }\n  }\n\n  // Measurements from third parties can be off, which would create invalid spans, dropping transactions in the process.\n  if (measureStartTimestamp <= measureEndTimestamp) {\n    startAndEndSpan(span, measureStartTimestamp, measureEndTimestamp, {\n      name: entry.name ,\n      op: entry.entryType ,\n      attributes,\n    });\n  }\n}\n\n/**\n * Instrument navigation entries\n * exported only for tests\n */\nfunction _addNavigationSpans(span, entry, timeOrigin) {\n  (['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'] ).forEach(event => {\n    _addPerformanceNavigationTiming(span, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(span, entry, 'secureConnection', timeOrigin, 'TLS/SSL');\n  _addPerformanceNavigationTiming(span, entry, 'fetch', timeOrigin, 'cache');\n  _addPerformanceNavigationTiming(span, entry, 'domainLookup', timeOrigin, 'DNS');\n\n  _addRequest(span, entry, timeOrigin);\n}\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(\n  span,\n  entry,\n  event,\n  timeOrigin,\n  name = event,\n) {\n  const eventEnd = _getEndPropertyNameForNavigationTiming(event) ;\n  const end = entry[eventEnd];\n  const start = entry[`${event}Start`];\n  if (!start || !end) {\n    return;\n  }\n  startAndEndSpan(span, timeOrigin + msToSec(start), timeOrigin + msToSec(end), {\n    op: `browser.${name}`,\n    name: entry.name,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      ...(event === 'redirect' && entry.redirectCount != null ? { 'http.redirect_count': entry.redirectCount } : {}),\n    },\n  });\n}\n\nfunction _getEndPropertyNameForNavigationTiming(event) {\n  if (event === 'secureConnection') {\n    return 'connectEnd';\n  }\n  if (event === 'fetch') {\n    return 'domainLookupStart';\n  }\n  return `${event}End`;\n}\n\n/** Create request and response related spans */\nfunction _addRequest(span, entry, timeOrigin) {\n  const requestStartTimestamp = timeOrigin + msToSec(entry.requestStart );\n  const responseEndTimestamp = timeOrigin + msToSec(entry.responseEnd );\n  const responseStartTimestamp = timeOrigin + msToSec(entry.responseStart );\n  if (entry.responseEnd) {\n    // It is possible that we are collecting these metrics when the page hasn't finished loading yet, for example when the HTML slowly streams in.\n    // In this case, ie. when the document request hasn't finished yet, `entry.responseEnd` will be 0.\n    // In order not to produce faulty spans, where the end timestamp is before the start timestamp, we will only collect\n    // these spans when the responseEnd value is available. The backend (Relay) would drop the entire span if it contained faulty spans.\n    startAndEndSpan(span, requestStartTimestamp, responseEndTimestamp, {\n      op: 'browser.request',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      },\n    });\n\n    startAndEndSpan(span, responseStartTimestamp, responseEndTimestamp, {\n      op: 'browser.response',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      },\n    });\n  }\n}\n\n/**\n * Create resource-related spans.\n * Exported only for tests.\n */\nfunction _addResourceSpans(\n  span,\n  entry,\n  resourceUrl,\n  startTime,\n  duration,\n  timeOrigin,\n) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n\n  const parsedUrl = parseUrl(resourceUrl);\n\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics',\n  };\n  setResourceEntrySizeData(attributes, entry, 'transferSize', 'http.response_transfer_size');\n  setResourceEntrySizeData(attributes, entry, 'encodedBodySize', 'http.response_content_length');\n  setResourceEntrySizeData(attributes, entry, 'decodedBodySize', 'http.decoded_response_content_length');\n\n  // `deliveryType` is experimental and does not exist everywhere\n  const deliveryType = (entry ).deliveryType;\n  if (deliveryType != null) {\n    attributes['http.response_delivery_type'] = deliveryType;\n  }\n\n  // Types do not reflect this property yet\n  const renderBlockingStatus = (entry )\n    .renderBlockingStatus;\n  if (renderBlockingStatus) {\n    attributes['resource.render_blocking_status'] = renderBlockingStatus;\n  }\n\n  if (parsedUrl.protocol) {\n    attributes['url.scheme'] = parsedUrl.protocol.split(':').pop(); // the protocol returned by parseUrl includes a :, but OTEL spec does not, so we remove it.\n  }\n\n  if (parsedUrl.host) {\n    attributes['server.address'] = parsedUrl.host;\n  }\n\n  attributes['url.same_origin'] = resourceUrl.includes(WINDOW.location.origin);\n\n  const { name, version } = extractNetworkProtocol(entry.nextHopProtocol);\n  attributes['network.protocol.name'] = name;\n  attributes['network.protocol.version'] = version;\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  startAndEndSpan(span, startTimestamp, endTimestamp, {\n    name: resourceUrl.replace(WINDOW.location.origin, ''),\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource.other',\n    attributes,\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(span) {\n  const navigator = WINDOW.navigator ;\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  const connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      span.setAttribute('effectiveConnectionType', connection.effectiveType);\n    }\n\n    if (connection.type) {\n      span.setAttribute('connectionType', connection.type);\n    }\n\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = { value: connection.rtt, unit: 'millisecond' };\n    }\n  }\n\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    span.setAttribute('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    span.setAttribute('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to span to allow debugging */\nfunction _setWebVitalAttributes(span) {\n  if (_lcpEntry) {\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      span.setAttribute('lcp.element', htmlTreeAsString(_lcpEntry.element));\n    }\n\n    if (_lcpEntry.id) {\n      span.setAttribute('lcp.id', _lcpEntry.id);\n    }\n\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      span.setAttribute('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n\n    if (_lcpEntry.loadTime != null) {\n      // loadTime is the time of LCP that's related to receiving the LCP element response..\n      span.setAttribute('lcp.loadTime', _lcpEntry.loadTime);\n    }\n\n    if (_lcpEntry.renderTime != null) {\n      // renderTime is loadTime + rendering time\n      // it's 0 if the LCP element is loaded from a 3rd party origin that doesn't send the\n      // `Timing-Allow-Origin` header.\n      span.setAttribute('lcp.renderTime', _lcpEntry.renderTime);\n    }\n\n    span.setAttribute('lcp.size', _lcpEntry.size);\n  }\n\n  // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n  if (_clsEntry?.sources) {\n    _clsEntry.sources.forEach((source, index) =>\n      span.setAttribute(`cls.source.${index + 1}`, htmlTreeAsString(source.node)),\n    );\n  }\n}\n\nfunction setResourceEntrySizeData(\n  attributes,\n  entry,\n  key,\n  dataKey,\n) {\n  const entryVal = entry[key];\n  if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {\n    attributes[dataKey] = entryVal;\n  }\n}\n\n/**\n * Add ttfb request time information to measurements.\n *\n * ttfb information is added via vendored web vitals library.\n */\nfunction _addTtfbRequestTimeToMeasurements(_measurements) {\n  const navEntry = getNavigationEntry(false);\n  if (!navEntry) {\n    return;\n  }\n\n  const { responseStart, requestStart } = navEntry;\n\n  if (requestStart <= responseStart) {\n    _measurements['ttfb.requestTime'] = {\n      value: responseStart - requestStart,\n      unit: 'millisecond',\n    };\n  }\n}\n\nexport { _addMeasureSpans, _addNavigationSpans, _addResourceSpans, addPerformanceEntries, startTrackingInteractions, startTrackingLongAnimationFrames, startTrackingLongTasks, startTrackingWebVitals };\n//# sourceMappingURL=browserMetrics.js.map\n"],"names":["MAX_INT_AS_BYTES","_performanceCursor","_measurements","_lcpEntry","_clsEntry","startTrackingWebVitals","recordClsStandaloneSpans","performance","getBrowserPerformanceAPI","browserPerformanceTimeOrigin","WINDOW","fidCleanupCallback","_trackFID","lcpCleanupCallback","_trackLCP","ttfbCleanupCallback","_trackTtfb","clsCleanupCallback","trackClsAsStandaloneSpan","_trackCLS","startTrackingLongTasks","addPerformanceInstrumentationHandler","entries","parent","getActiveSpan","parentOp","parentStartTimestamp","spanToJSON","entry","startTime","msToSec","duration","startAndEndSpan","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","startTrackingLongAnimationFrames","list","attributes","initialScript","invoker","invokerType","sourceURL","sourceFunctionName","sourceCharPosition","startTrackingInteractions","spanOptions","htmlTreeAsString","componentName","getComponentName","addClsInstrumentationHandler","metric","addLcpInstrumentationHandler","addFidInstrumentationHandler","timeOrigin","addTtfbInstrumentationHandler","addPerformanceEntries","span","options","origin","performanceEntries","op","transactionStartTime","_addNavigationSpans","_addMeasureSpans","firstHidden","getVisibilityWatcher","shouldRecord","_addResourceSpans","_trackNavigator","_addTtfbRequestTimeToMeasurements","fidMark","measurementName","measurement","setMeasurement","getActivationStart","_setWebVitalAttributes","navEntry","getNavigationEntry","requestTime","measureStartTimestamp","startTimeStamp","measureEndTimestamp","key","value","isPrimitive","event","_addPerformanceNavigationTiming","_addRequest","name","eventEnd","_getEndPropertyNameForNavigationTiming","end","start","requestStartTimestamp","responseEndTimestamp","responseStartTimestamp","resourceUrl","parsedUrl","parseUrl","setResourceEntrySizeData","deliveryType","renderBlockingStatus","version","extractNetworkProtocol","startTimestamp","endTimestamp","navigator","connection","isMeasurementValue","source","index","dataKey","entryVal","responseStart","requestStart"],"mappings":"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","x_google_ignoreList":[0]}