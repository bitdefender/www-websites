{"version":3,"file":"index.js","sources":["../../../../src/plugins/rum-conversion/src/index.js"],"sourcesContent":["/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nconst { sampleRUM } = window.hlx.rum;\n// SampleRUM always initialization should happen in lib-franklin\n// we need to initialize it here until the initialization is part of\n// the boilerplate.\nsampleRUM.always = sampleRUM.always || [];\nsampleRUM.always.on = (chkpnt, fn) => {\n  sampleRUM.always[chkpnt] = fn;\n};\n\n/**\n* Registers the 'convert' function to `sampleRUM` which sends\n* variant and convert events upon conversion.\n* The function will register a listener for an element if listenTo parameter is provided.\n* listenTo supports 'submit' and 'click'.\n* If listenTo is not provided, the information is used to track a conversion event.\n*/\nsampleRUM.drain('convert', (cevent, cvalueThunk, element, listenTo = []) => {\n  async function trackConversion(celement) {\n    const MAX_SESSION_LENGTH = 1000 * 60 * 60 * 24 * 30; // 30 days\n    try {\n      // get all stored experiments from local storage (unified-decisioning-experiments)\n      const experiments = JSON.parse(localStorage.getItem('unified-decisioning-experiments'));\n      if (experiments) {\n        Object.entries(experiments)\n          .map(([experiment, { treatment, date }]) => ({ experiment, treatment, date }))\n          .filter(({ date }) => Date.now() - new Date(date) < MAX_SESSION_LENGTH)\n          .forEach(({ experiment, treatment }) => {\n            // send conversion event for each experiment that has been seen by this visitor\n            sampleRUM('variant', { source: experiment, target: treatment });\n          });\n      }\n      // send conversion event\n      const cvalue = typeof cvalueThunk === 'function' ? await cvalueThunk(element) : cvalueThunk;\n\n      const data = { source: cevent, target: cvalue, element: celement };\n      sampleRUM('convert', data);\n      // Following if statement must be removed once always mechanism is present in the boilerplate\n      if (sampleRUM.always && sampleRUM.always.convert) {\n        sampleRUM.always.convert(data);\n      }\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.log('error reading experiments', e);\n    }\n  }\n\n  function registerConversionListener(elements) {\n    // if elements is an array or nodelist, register a conversion event for each element\n    if (Array.isArray(elements) || elements instanceof NodeList) {\n      elements.forEach((e) => registerConversionListener(e, listenTo, cevent, cvalueThunk));\n    } else {\n      listenTo.forEach((eventName) => element.addEventListener(\n        eventName,\n        (e) => trackConversion(e.target),\n      ));\n    }\n  }\n\n  if (element && listenTo.length) {\n    registerConversionListener(element, listenTo, cevent, cvalueThunk);\n  } else {\n    trackConversion(element, cevent, cvalueThunk);\n  }\n});\n\n/**\n * Returns the label used for tracking link clicks\n * @param {Element} element link element\n * @returns link label used for tracking converstion\n */\nfunction getLinkLabel(element) {\n  return element.title ? this.toClassName(element.title) : this.toClassName(element.textContent);\n}\n\nfunction getConversionNameMetadata(element) {\n  const text = element.title || element.textContent;\n  return this.getMetadata(`conversion-name--${text.toLowerCase().replace(/[^0-9a-z]/gi, '-')}-`);\n}\n\nfunction findConversionValue(parent, fieldName) {\n  // Try to find the element by Id or Name\n  const valueElement = document.getElementById(fieldName) || parent.querySelector(`[name='${fieldName}']`);\n  if (valueElement) {\n    return valueElement.value;\n  }\n  // Find the element by the inner text of the label\n  return Array.from(parent.getElementsByTagName('label'))\n    .filter((l) => l.innerText.trim().toLowerCase() === fieldName.toLowerCase())\n    .map((label) => document.getElementById(label.htmlFor))\n    .filter((field) => !!field)\n    .map((field) => field.value)\n    .pop();\n}\n\n/**\n * Registers conversion listeners according to the metadata configured in the document.\n * @param {Element} parent element where to find potential event conversion sources\n * @param {string} defaultFormConversionName In case of form conversions, default\n * name for the conversion in case there is no conversion name defined\n * in the document or section metadata. If the form is defined in a fragment\n * this is typically the path to the fragment.\n * The parameter is optional, if no value is passed, and conversion\n * name is not defined in the document or section metadata,\n * the id of the HTML form element will be used as conversion name\n */\n// eslint-disable-next-line import/prefer-default-export\nexport async function initConversionTracking(parent = document, defaultFormConversionName = '') {\n  const conversionElements = {\n    form: () => {\n      // Track all forms\n      parent.querySelectorAll('form').forEach((element) => {\n        const section = element.closest('div.section');\n        if (section.dataset.conversionValueField) {\n          const cvField = section.dataset.conversionValueField.trim();\n          // this will track the value of the element with the id specified in\n          // the \"Conversion Element\" field.\n          // ideally, this should not be an ID, but the case-insensitive name label of the element.\n          sampleRUM.convert(undefined, (cvParent) => findConversionValue(cvParent, cvField), element, ['submit']);\n        }\n        let formConversionName = section.dataset.conversionName || this.getMetadata('conversion-name');\n        if (!formConversionName) {\n          // if no conversion name is defined in the metadata,\n          // use the conversion name passed as parameter or the form or id\n          formConversionName = defaultFormConversionName\n            ? this.toClassName(defaultFormConversionName) : element.id;\n        }\n        sampleRUM.convert(formConversionName, undefined, element, ['submit']);\n      });\n    },\n    link: () => {\n      // track all links\n      Array.from(parent.querySelectorAll('a[href]'))\n        .map((element) => ({\n          element,\n          cevent: getConversionNameMetadata.call(this, element) || this.getMetadata('conversion-name') || getLinkLabel.call(this, element),\n        }))\n        .forEach(({ element, cevent }) => {\n          sampleRUM.convert(cevent, undefined, element, ['click']);\n        });\n    },\n    'labeled-link': () => {\n      // track only the links configured in the metadata\n      const linkLabels = this.getMetadata('conversion-link-labels') || '';\n      const trackedLabels = linkLabels.split(',')\n        .map((p) => p.trim())\n        .map(this.toClassName);\n\n      Array.from(parent.querySelectorAll('a[href]'))\n        .filter((element) => trackedLabels.includes(getLinkLabel.call(this, element)))\n        .map((element) => ({\n          element,\n          cevent: getConversionNameMetadata.call(this, element) || this.getMetadata('conversion-name') || getLinkLabel.call(this, element),\n        }))\n        .forEach(({ element, cevent }) => {\n          sampleRUM.convert(cevent, undefined, element, ['click']);\n        });\n    },\n  };\n\n  const declaredConversionElements = this.getMetadata('conversion-element') ? this.getMetadata('conversion-element').split(',').map((ce) => this.toClassName(ce.trim())) : [];\n\n  Object.keys(conversionElements)\n    .filter((ce) => declaredConversionElements.includes(ce))\n    .forEach((cefn) => conversionElements[cefn]());\n}\n"],"names":["sampleRUM","chkpnt","fn","cevent","cvalueThunk","element","listenTo","trackConversion","celement","experiments","experiment","treatment","date","cvalue","data","e","registerConversionListener","elements","eventName","getLinkLabel","getConversionNameMetadata","text","findConversionValue","parent","fieldName","valueElement","l","label","field","initConversionTracking","defaultFormConversionName","conversionElements","section","cvField","cvParent","formConversionName","trackedLabels","p","declaredConversionElements","ce","cefn"],"mappings":"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"}