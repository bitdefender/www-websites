{"version":3,"file":"stack-parsers.js","sources":["../../../../../../../node_modules/@sentry/browser/build/npm/esm/stack-parsers.js"],"sourcesContent":["import { createStackParser, UNKNOWN_FUNCTION } from '@sentry/core';\n\nconst OPERA10_PRIORITY = 10;\nconst OPERA11_PRIORITY = 20;\nconst CHROME_PRIORITY = 30;\nconst WINJS_PRIORITY = 40;\nconst GECKO_PRIORITY = 50;\n\nfunction createFrame(filename, func, lineno, colno) {\n  const frame = {\n    filename,\n    function: func === '<anonymous>' ? UNKNOWN_FUNCTION : func,\n    in_app: true, // All browser frames are considered in_app\n  };\n\n  if (lineno !== undefined) {\n    frame.lineno = lineno;\n  }\n\n  if (colno !== undefined) {\n    frame.colno = colno;\n  }\n\n  return frame;\n}\n\n// This regex matches frames that have no function name (ie. are at the top level of a module).\n// For example \"at http://localhost:5000//script.js:1:126\"\n// Frames _with_ function names usually look as follows: \"at commitLayoutEffects (react-dom.development.js:23426:1)\"\nconst chromeRegexNoFnName = /^\\s*at (\\S+?)(?::(\\d+))(?::(\\d+))\\s*$/i;\n\n// This regex matches all the frames that have a function name.\nconst chromeRegex =\n  /^\\s*at (?:(.+?\\)(?: \\[.+\\])?|.*?) ?\\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\n\nconst chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\n// Chromium based browsers: Chrome, Brave, new Opera, new Edge\n// We cannot call this variable `chrome` because it can conflict with global `chrome` variable in certain environments\n// See: https://github.com/getsentry/sentry-javascript/issues/6880\nconst chromeStackParserFn = line => {\n  // If the stack line has no function name, we need to parse it differently\n  const noFnParts = chromeRegexNoFnName.exec(line) ;\n\n  if (noFnParts) {\n    const [, filename, line, col] = noFnParts;\n    return createFrame(filename, UNKNOWN_FUNCTION, +line, +col);\n  }\n\n  const parts = chromeRegex.exec(line) ;\n\n  if (parts) {\n    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n    if (isEval) {\n      const subMatch = chromeEvalRegex.exec(parts[2]) ;\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = subMatch[1]; // url\n        parts[3] = subMatch[2]; // line\n        parts[4] = subMatch[3]; // column\n      }\n    }\n\n    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now\n    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)\n    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n\n    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);\n  }\n\n  return;\n};\n\nconst chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn];\n\n// gecko regex: `(?:bundle|\\d+\\.js)`: `bundle` is for react native, `\\d+\\.js` also but specifically for ram bundles because it\n// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js\n// We need this specific case for now because we want no other regex to match.\nconst geckoREgex =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:[-a-z]+)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nconst geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nconst gecko = line => {\n  const parts = geckoREgex.exec(line) ;\n\n  if (parts) {\n    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    if (isEval) {\n      const subMatch = geckoEvalRegex.exec(parts[3]) ;\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line number\n        parts[1] = parts[1] || 'eval';\n        parts[3] = subMatch[1];\n        parts[4] = subMatch[2];\n        parts[5] = ''; // no column when eval\n      }\n    }\n\n    let filename = parts[3];\n    let func = parts[1] || UNKNOWN_FUNCTION;\n    [func, filename] = extractSafariExtensionDetails(func, filename);\n\n    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);\n  }\n\n  return;\n};\n\nconst geckoStackLineParser = [GECKO_PRIORITY, gecko];\n\nconst winjsRegex = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:[-a-z]+):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nconst winjs = line => {\n  const parts = winjsRegex.exec(line) ;\n\n  return parts\n    ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined)\n    : undefined;\n};\n\nconst winjsStackLineParser = [WINJS_PRIORITY, winjs];\n\nconst opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\n\nconst opera10 = line => {\n  const parts = opera10Regex.exec(line) ;\n  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;\n};\n\nconst opera10StackLineParser = [OPERA10_PRIORITY, opera10];\n\nconst opera11Regex =\n  / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\\(.*\\))? in (.*):\\s*$/i;\n\nconst opera11 = line => {\n  const parts = opera11Regex.exec(line) ;\n  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;\n};\n\nconst opera11StackLineParser = [OPERA11_PRIORITY, opera11];\n\nconst defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser];\n\nconst defaultStackParser = createStackParser(...defaultStackLineParsers);\n\n/**\n * Safari web extensions, starting version unknown, can produce \"frames-only\" stacktraces.\n * What it means, is that instead of format like:\n *\n * Error: wat\n *   at function@url:row:col\n *   at function@url:row:col\n *   at function@url:row:col\n *\n * it produces something like:\n *\n *   function@url:row:col\n *   function@url:row:col\n *   function@url:row:col\n *\n * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.\n * This function is extracted so that we can use it in both places without duplicating the logic.\n * Unfortunately \"just\" changing RegExp is too complicated now and making it pass all tests\n * and fix this case seems like an impossible, or at least way too time-consuming task.\n */\nconst extractSafariExtensionDetails = (func, filename) => {\n  const isSafariExtension = func.indexOf('safari-extension') !== -1;\n  const isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;\n\n  return isSafariExtension || isSafariWebExtension\n    ? [\n        func.indexOf('@') !== -1 ? (func.split('@')[0] ) : UNKNOWN_FUNCTION,\n        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`,\n      ]\n    : [func, filename];\n};\n\nexport { chromeStackLineParser, defaultStackLineParsers, defaultStackParser, geckoStackLineParser, opera10StackLineParser, opera11StackLineParser, winjsStackLineParser };\n//# sourceMappingURL=stack-parsers.js.map\n"],"names":["CHROME_PRIORITY","GECKO_PRIORITY","createFrame","filename","func","lineno","colno","frame","UNKNOWN_FUNCTION","chromeRegexNoFnName","chromeRegex","chromeEvalRegex","chromeStackParserFn","line","noFnParts","col","parts","subMatch","extractSafariExtensionDetails","chromeStackLineParser","geckoREgex","geckoEvalRegex","gecko","geckoStackLineParser","defaultStackLineParsers","defaultStackParser","createStackParser","isSafariExtension","isSafariWebExtension"],"mappings":"+GAIA,MAAMA,EAAkB,GAElBC,EAAiB,GAEvB,SAASC,EAAYC,EAAUC,EAAMC,EAAQC,EAAO,CAClD,MAAMC,EAAQ,CACZ,SAAAJ,EACA,SAAUC,IAAS,cAAgBI,EAAmBJ,EACtD,OAAQ,EACT,EAED,OAAIC,IAAW,SACbE,EAAM,OAASF,GAGbC,IAAU,SACZC,EAAM,MAAQD,GAGTC,CACT,CAKA,MAAME,EAAsB,yCAGtBC,EACJ,6IAEIC,EAAkB,gCAKlBC,EAAsBC,GAAQ,CAElC,MAAMC,EAAYL,EAAoB,KAAKI,CAAI,EAE/C,GAAIC,EAAW,CACb,KAAM,EAAGX,EAAUU,EAAME,CAAG,EAAID,EAChC,OAAOZ,EAAYC,EAAUK,EAAkB,CAACK,EAAM,CAACE,CAAG,CAC9D,CAEE,MAAMC,EAAQN,EAAY,KAAKG,CAAI,EAEnC,GAAIG,EAAO,CAGT,GAFeA,EAAM,CAAC,GAAKA,EAAM,CAAC,EAAE,QAAQ,MAAM,IAAM,EAE5C,CACV,MAAMC,EAAWN,EAAgB,KAAKK,EAAM,CAAC,CAAC,EAE1CC,IAEFD,EAAM,CAAC,EAAIC,EAAS,CAAC,EACrBD,EAAM,CAAC,EAAIC,EAAS,CAAC,EACrBD,EAAM,CAAC,EAAIC,EAAS,CAAC,EAE7B,CAII,KAAM,CAACb,EAAMD,CAAQ,EAAIe,EAA8BF,EAAM,CAAC,GAAKR,EAAkBQ,EAAM,CAAC,CAAC,EAE7F,OAAOd,EAAYC,EAAUC,EAAMY,EAAM,CAAC,EAAI,CAACA,EAAM,CAAC,EAAI,OAAWA,EAAM,CAAC,EAAI,CAACA,EAAM,CAAC,EAAI,MAAS,CACzG,CAGA,EAEMG,EAAwB,CAACnB,EAAiBY,CAAmB,EAK7DQ,EACJ,uIACIC,EAAiB,gDAEjBC,EAAQT,GAAQ,CACpB,MAAMG,EAAQI,EAAW,KAAKP,CAAI,EAElC,GAAIG,EAAO,CAET,GADeA,EAAM,CAAC,GAAKA,EAAM,CAAC,EAAE,QAAQ,SAAS,EAAI,GAC7C,CACV,MAAMC,EAAWI,EAAe,KAAKL,EAAM,CAAC,CAAC,EAEzCC,IAEFD,EAAM,CAAC,EAAIA,EAAM,CAAC,GAAK,OACvBA,EAAM,CAAC,EAAIC,EAAS,CAAC,EACrBD,EAAM,CAAC,EAAIC,EAAS,CAAC,EACrBD,EAAM,CAAC,EAAI,GAEnB,CAEI,IAAIb,EAAWa,EAAM,CAAC,EAClBZ,EAAOY,EAAM,CAAC,GAAKR,EACvB,OAACJ,EAAMD,CAAQ,EAAIe,EAA8Bd,EAAMD,CAAQ,EAExDD,EAAYC,EAAUC,EAAMY,EAAM,CAAC,EAAI,CAACA,EAAM,CAAC,EAAI,OAAWA,EAAM,CAAC,EAAI,CAACA,EAAM,CAAC,EAAI,MAAS,CACzG,CAGA,EAEMO,EAAuB,CAACtB,EAAgBqB,CAAK,EAiC7CE,EAA0B,CAACL,EAAuBI,CAAoB,EAEtEE,EAAqBC,EAAkB,GAAGF,CAAuB,EAsBjEN,EAAgC,CAACd,EAAMD,IAAa,CACxD,MAAMwB,EAAoBvB,EAAK,QAAQ,kBAAkB,IAAM,GACzDwB,EAAuBxB,EAAK,QAAQ,sBAAsB,IAAM,GAEtE,OAAOuB,GAAqBC,EACxB,CACExB,EAAK,QAAQ,GAAG,IAAM,GAAMA,EAAK,MAAM,GAAG,EAAE,CAAC,EAAMI,EACnDmB,EAAoB,oBAAoBxB,CAAQ,GAAK,wBAAwBA,CAAQ,EAC7F,EACM,CAACC,EAAMD,CAAQ,CACrB","x_google_ignoreList":[0]}