{"version":3,"file":"fetch.js","sources":["../../../../../../../../node_modules/@sentry/browser/build/npm/esm/transports/fetch.js"],"sourcesContent":["import { createTransport, rejectedSyncPromise } from '@sentry/core';\nimport { getNativeImplementation, clearCachedImplementation } from '@sentry-internal/browser-utils';\n\n/**\n * Creates a Transport that uses the Fetch API to send events to Sentry.\n */\nfunction makeFetchTransport(\n  options,\n  nativeFetch = getNativeImplementation('fetch'),\n) {\n  let pendingBodySize = 0;\n  let pendingCount = 0;\n\n  function makeRequest(request) {\n    const requestSize = request.body.length;\n    pendingBodySize += requestSize;\n    pendingCount++;\n\n    const requestOptions = {\n      body: request.body,\n      method: 'POST',\n      referrerPolicy: 'strict-origin',\n      headers: options.headers,\n      // Outgoing requests are usually cancelled when navigating to a different page, causing a \"TypeError: Failed to\n      // fetch\" error and sending a \"network_error\" client-outcome - in Chrome, the request status shows \"(cancelled)\".\n      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're\n      // frequently sending events right before the user is switching pages (eg. when finishing navigation transactions).\n      // Gotchas:\n      // - `keepalive` isn't supported by Firefox\n      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):\n      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.\n      //   We will therefore only activate the flag when we're below that limit.\n      // There is also a limit of requests that can be open at the same time, so we also limit this to 15\n      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details\n      keepalive: pendingBodySize <= 60000 && pendingCount < 15,\n      ...options.fetchOptions,\n    };\n\n    if (!nativeFetch) {\n      clearCachedImplementation('fetch');\n      return rejectedSyncPromise('No fetch implementation available');\n    }\n\n    try {\n      // TODO: This may need a `suppressTracing` call in the future when we switch the browser SDK to OTEL\n      return nativeFetch(options.url, requestOptions).then(response => {\n        pendingBodySize -= requestSize;\n        pendingCount--;\n        return {\n          statusCode: response.status,\n          headers: {\n            'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),\n            'retry-after': response.headers.get('Retry-After'),\n          },\n        };\n      });\n    } catch (e) {\n      clearCachedImplementation('fetch');\n      pendingBodySize -= requestSize;\n      pendingCount--;\n      return rejectedSyncPromise(e);\n    }\n  }\n\n  return createTransport(options, makeRequest);\n}\n\nexport { makeFetchTransport };\n//# sourceMappingURL=fetch.js.map\n"],"names":["makeFetchTransport","options","nativeFetch","getNativeImplementation","pendingBodySize","pendingCount","makeRequest","request","requestSize","requestOptions","clearCachedImplementation","rejectedSyncPromise","response","createTransport"],"mappings":"iVAMA,SAASA,EACPC,EACAC,EAAcC,EAAwB,OAAO,EAC7C,CACA,IAAIC,EAAkB,EAClBC,EAAe,EAEnB,SAASC,EAAYC,EAAS,CAC5B,MAAMC,EAAcD,EAAQ,KAAK,OACjCH,GAAmBI,EACnBH,IAEA,MAAMI,EAAiB,CACrB,KAAMF,EAAQ,KACd,OAAQ,OACR,eAAgB,gBAChB,QAASN,EAAQ,QAYjB,UAAWG,GAAmB,KAASC,EAAe,GACtD,GAAGJ,EAAQ,YACZ,EAED,GAAI,CAACC,EACH,OAAAQ,EAA0B,OAAO,EAC1BC,EAAoB,mCAAmC,EAGhE,GAAI,CAEF,OAAOT,EAAYD,EAAQ,IAAKQ,CAAc,EAAE,KAAKG,IACnDR,GAAmBI,EACnBH,IACO,CACL,WAAYO,EAAS,OACrB,QAAS,CACP,uBAAwBA,EAAS,QAAQ,IAAI,sBAAsB,EACnE,cAAeA,EAAS,QAAQ,IAAI,aAAa,CAClD,CACF,EACF,CACF,OAAQ,EAAG,CACV,OAAAF,EAA0B,OAAO,EACjCN,GAAmBI,EACnBH,IACOM,EAAoB,CAAC,CAClC,CACA,CAEE,OAAOE,EAAgBZ,EAASK,CAAW,CAC7C","x_google_ignoreList":[0]}