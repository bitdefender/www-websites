import{getClient as $,getCurrentScope as P}from"../currentScopes.js";import{DEBUG_BUILD as C}from"../debug-build.js";import{SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON as w}from"../semanticAttributes.js";import{hasSpansEnabled as j}from"../utils/hasSpansEnabled.js";import{_setSpanForScope as G}from"../utils/spanOnScope.js";import{getActiveSpan as q,spanTimeInputToSeconds as K,getSpanDescendants as O,spanToJSON as d,removeChildSpanFromSpan as Q}from"../utils/spanUtils.js";import{logger as f}from"../utils-hoist/logger.js";import{timestampInSeconds as D}from"../utils-hoist/time.js";import{getDynamicSamplingContextFromSpan as V,freezeDscOnSpan as Z}from"./dynamicSamplingContext.js";import{SentryNonRecordingSpan as J}from"./sentryNonRecordingSpan.js";import{SPAN_STATUS_ERROR as z}from"./spanstatus.js";import{startInactiveSpan as tt}from"./trace.js";const b={idleTimeout:1e3,finalTimeout:3e4,childSpanTimeout:15e3},et="heartbeatFailed",nt="idleTimeout",it="finalTimeout",st="externalFinish";function It(g,o={}){const a=new Map;let r=!1,m,l=st,A=!o.disableAutoFinish;const u=[],{idleTimeout:N=b.idleTimeout,finalTimeout:F=b.finalTimeout,childSpanTimeout:x=b.childSpanTimeout,beforeSpanEnd:M}=o,S=$();if(!S||!j()){const t=new J,i={sample_rate:"0",sampled:"false",...V(t)};return Z(t,i),t}const k=P(),W=q(),e=at(g);e.end=new Proxy(e.end,{apply(t,i,y){if(M&&M(e),i instanceof J)return;const[U,...T]=y,c=U||D(),n=K(c),_=O(e).filter(s=>s!==e);if(!_.length)return L(n),Reflect.apply(t,i,[n,...T]);const I=_.map(s=>d(s).timestamp).filter(s=>!!s),E=I.length?Math.max(...I):void 0,p=d(e).start_timestamp,h=Math.min(p?p+F/1e3:1/0,Math.max(p||-1/0,Math.min(n,E||1/0)));return L(h),Reflect.apply(t,i,[h,...T])}});function v(){m&&(clearTimeout(m),m=void 0)}function R(t){v(),m=setTimeout(()=>{!r&&a.size===0&&A&&(l=nt,e.end(t))},N)}function H(t){m=setTimeout(()=>{!r&&A&&(l=et,e.end(t))},x)}function X(t){v(),a.set(t,!0);const i=D();H(i+x/1e3)}function Y(t){if(a.has(t)&&a.delete(t),a.size===0){const i=D();R(i+N/1e3)}}function L(t){r=!0,a.clear(),u.forEach(n=>n()),G(k,W);const i=d(e),{start_timestamp:y}=i;if(!y)return;i.data[w]||e.setAttribute(w,l),f.log(`[Tracing] Idle span "${i.op}" finished`);const T=O(e).filter(n=>n!==e);let c=0;T.forEach(n=>{n.isRecording()&&(n.setStatus({code:z,message:"cancelled"}),n.end(t),C&&f.log("[Tracing] Cancelling span since span ended early",JSON.stringify(n,void 0,2)));const _=d(n),{timestamp:I=0,start_timestamp:E=0}=_,p=E<=t,h=(F+N)/1e3,s=I-E<=h;if(C){const B=JSON.stringify(n,void 0,2);p?s||f.log("[Tracing] Discarding span since it finished after idle span final timeout",B):f.log("[Tracing] Discarding span since it happened after idle span was finished",B)}(!s||!p)&&(Q(e,n),c++)}),c>0&&e.setAttribute("sentry.idle_span_discarded_spans",c)}return u.push(S.on("spanStart",t=>{if(r||t===e||d(t).timestamp)return;O(e).includes(t)&&X(t.spanContext().spanId)})),u.push(S.on("spanEnd",t=>{r||Y(t.spanContext().spanId)})),u.push(S.on("idleSpanEnableAutoFinish",t=>{t===e&&(A=!0,R(),a.size&&H())})),o.disableAutoFinish||R(),setTimeout(()=>{r||(e.setStatus({code:z,message:"deadline_exceeded"}),l=it,e.end())},F),e}function at(g){const o=tt(g);return G(P(),o),C&&f.log("[Tracing] Started span is an idle span"),o}export{b as TRACING_DEFAULTS,It as startIdleSpan};
//# sourceMappingURL=idleSpan.js.map
