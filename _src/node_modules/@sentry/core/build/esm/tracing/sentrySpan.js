import{getClient as N,getCurrentScope as R}from"../currentScopes.js";import{DEBUG_BUILD as d}from"../debug-build.js";import{createSpanEnvelope as v}from"../envelope.js";import{SEMANTIC_ATTRIBUTE_SENTRY_OP as c,SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN as S,SEMANTIC_ATTRIBUTE_SENTRY_SOURCE as u,SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME as k,SEMANTIC_ATTRIBUTE_PROFILE_ID as U,SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME as l}from"../semanticAttributes.js";import{TRACE_FLAG_SAMPLED as D,TRACE_FLAG_NONE as O,spanTimeInputToSeconds as m,convertSpanLinksForEnvelope as L,getRootSpan as h,getStatusMessage as y,spanToJSON as T,getSpanDescendants as B,spanToTransactionTraceContext as F}from"../utils/spanUtils.js";import{logger as _}from"../utils-hoist/logger.js";import{generateTraceId as C,generateSpanId as P}from"../utils-hoist/propagationContext.js";import{timestampInSeconds as f}from"../utils-hoist/time.js";import{getDynamicSamplingContextFromSpan as G}from"./dynamicSamplingContext.js";import{logSpanEnd as Y}from"./logSpans.js";import{timedEventsToMeasurements as E}from"./measurement.js";import{getCapturedScopesOnSpan as I}from"./utils.js";const g=1e3;class J{constructor(t={}){this._traceId=t.traceId||C(),this._spanId=t.spanId||P(),this._startTime=t.startTimestamp||f(),this._links=t.links,this._attributes={},this.setAttributes({[S]:"manual",[c]:t.op,...t.attributes}),this._name=t.name,t.parentSpanId&&(this._parentSpanId=t.parentSpanId),"sampled"in t&&(this._sampled=t.sampled),t.endTimestamp&&(this._endTime=t.endTimestamp),this._events=[],this._isStandaloneSpan=t.isStandalone,this._endTime&&this._onSpanEnded()}addLink(t){return this._links?this._links.push(t):this._links=[t],this}addLinks(t){return this._links?this._links.push(...t):this._links=t,this}recordException(t,e){}spanContext(){const{_spanId:t,_traceId:e,_sampled:i}=this;return{spanId:t,traceId:e,traceFlags:i?D:O}}setAttribute(t,e){return e===void 0?delete this._attributes[t]:this._attributes[t]=e,this}setAttributes(t){return Object.keys(t).forEach(e=>this.setAttribute(e,t[e])),this}updateStartTime(t){this._startTime=m(t)}setStatus(t){return this._status=t,this}updateName(t){return this._name=t,this.setAttribute(u,"custom"),this}end(t){this._endTime||(this._endTime=m(t),Y(this),this._onSpanEnded())}getSpanJSON(){return{data:this._attributes,description:this._name,op:this._attributes[c],parent_span_id:this._parentSpanId,span_id:this._spanId,start_timestamp:this._startTime,status:y(this._status),timestamp:this._endTime,trace_id:this._traceId,origin:this._attributes[S],profile_id:this._attributes[U],exclusive_time:this._attributes[k],measurements:E(this._events),is_segment:this._isStandaloneSpan&&h(this)===this||void 0,segment_id:this._isStandaloneSpan?h(this).spanContext().spanId:void 0,links:L(this._links)}}isRecording(){return!this._endTime&&!!this._sampled}addEvent(t,e,i){d&&_.log("[Tracing] Adding an event to span:",t);const a=A(e)?e:i||f(),r=A(e)?{}:e||{},o={name:t,time:m(a),attributes:r};return this._events.push(o),this}isStandaloneSpan(){return!!this._isStandaloneSpan}_onSpanEnded(){const t=N();if(t&&t.emit("spanEnd",this),!(this._isStandaloneSpan||this===h(this)))return;if(this._isStandaloneSpan){this._sampled?w(v([this],t)):(d&&_.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."),t&&t.recordDroppedEvent("sample_rate","span"));return}const i=this._convertSpanToTransaction();i&&(I(this).scope||R()).captureEvent(i)}_convertSpanToTransaction(){if(!b(T(this)))return;this._name||(d&&_.warn("Transaction has no name, falling back to `<unlabeled transaction>`."),this._name="<unlabeled transaction>");const{scope:t,isolationScope:e}=I(this);if(this._sampled!==!0)return;const a=B(this).filter(n=>n!==this&&!j(n)).map(n=>T(n)).filter(b),r=this._attributes[u];delete this._attributes[l],a.forEach(n=>{delete n.data[l]});const o={contexts:{trace:F(this)},spans:a.length>g?a.sort((n,M)=>n.start_timestamp-M.start_timestamp).slice(0,g):a,start_timestamp:this._startTime,timestamp:this._endTime,transaction:this._name,type:"transaction",sdkProcessingMetadata:{capturedSpanScope:t,capturedSpanIsolationScope:e,dynamicSamplingContext:G(this)},...r&&{transaction_info:{source:r}}},p=E(this._events);return p&&Object.keys(p).length&&(d&&_.log("[Measurements] Adding measurements to transaction event",JSON.stringify(p,void 0,2)),o.measurements=p),o}}function A(s){return s&&typeof s=="number"||s instanceof Date||Array.isArray(s)}function b(s){return!!s.start_timestamp&&!!s.timestamp&&!!s.span_id&&!!s.trace_id}function j(s){return s instanceof J&&s.isStandaloneSpan()}function w(s){const t=N();if(!t)return;const e=s[1];if(!e||e.length===0){t.recordDroppedEvent("before_send","span");return}t.sendEnvelope(s)}export{J as SentrySpan};
//# sourceMappingURL=sentrySpan.js.map
