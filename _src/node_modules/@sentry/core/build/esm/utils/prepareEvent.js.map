{"version":3,"file":"prepareEvent.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/utils/prepareEvent.js"],"sourcesContent":["import { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { getGlobalScope } from '../currentScopes.js';\nimport { notifyEventProcessors } from '../eventProcessors.js';\nimport { Scope } from '../scope.js';\nimport { getFilenameToDebugIdMap } from '../utils-hoist/debug-ids.js';\nimport { uuid4, addExceptionMechanism } from '../utils-hoist/misc.js';\nimport { normalize } from '../utils-hoist/normalize.js';\nimport { truncate } from '../utils-hoist/string.js';\nimport { dateTimestampInSeconds } from '../utils-hoist/time.js';\nimport { mergeScopeData, applyScopeDataToEvent } from './applyScopeDataToEvent.js';\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(\n  options,\n  event,\n  hint,\n  scope,\n  client,\n  isolationScope,\n) {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;\n  const prepared = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  if (client) {\n    client.emit('applyFrameMetadata', event);\n  }\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n\n  if (hint.mechanism) {\n    addExceptionMechanism(prepared, hint.mechanism);\n  }\n\n  const clientEventProcessors = client ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Scope.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = getGlobalScope().getScopeData();\n\n  if (isolationScope) {\n    const isolationData = isolationScope.getScopeData();\n    mergeScopeData(data, isolationData);\n  }\n\n  if (finalScope) {\n    const finalScopeData = finalScope.getScopeData();\n    mergeScopeData(data, finalScopeData);\n  }\n\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n\n  applyScopeDataToEvent(prepared, data);\n\n  const eventProcessors = [\n    ...clientEventProcessors,\n    // Run scope event processors _after_ all other processors\n    ...data.eventProcessors,\n  ];\n\n  const result = notifyEventProcessors(eventProcessors, prepared, hint);\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n * Enhances event using the client configuration.\n * It takes care of all \"static\" values like environment, release and `dist`,\n * as well as truncating overly long values.\n *\n * Only exported for tests.\n *\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  const { environment, release, dist, maxValueLength = 250 } = options;\n\n  // empty strings do not make sense for environment, release, and dist\n  // so we handle them the same as if they were not provided\n  event.environment = event.environment || environment || DEFAULT_ENVIRONMENT;\n\n  if (!event.release && release) {\n    event.release = release;\n  }\n\n  if (!event.dist && dist) {\n    event.dist = dist;\n  }\n\n  const request = event.request;\n  if (request?.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nfunction applyDebugIds(event, stackParser) {\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);\n\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.filename) {\n        frame.debug_id = filenameDebugIdMap[frame.filename];\n      }\n    });\n  });\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nfunction applyDebugMeta(event) {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap = {};\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.debug_id) {\n        if (frame.abs_path) {\n          filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n        } else if (frame.filename) {\n          filenameDebugIdMap[frame.filename] = frame.debug_id;\n        }\n        delete frame.debug_id;\n      }\n    });\n  });\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id,\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n\n  const normalized = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts?.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      return {\n        ...span,\n        ...(span.data && {\n          data: normalize(span.data, depth, maxBreadth),\n        }),\n      };\n    });\n  }\n\n  // event.contexts.flags (FeatureFlagContext) stores context for our feature\n  // flag integrations. It has a greater nesting depth than our other typed\n  // Contexts, so we re-normalize with a fixed depth of 3 here. We do not want\n  // to skip this in case of conflicting, user-provided context.\n  if (event.contexts?.flags && normalized.contexts) {\n    normalized.contexts.flags = normalize(event.contexts.flags, 3, maxBreadth);\n  }\n\n  return normalized;\n}\n\nfunction getFinalScope(scope, captureContext) {\n  if (!captureContext) {\n    return scope;\n  }\n\n  const finalScope = scope ? scope.clone() : new Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nfunction parseEventHintOrCaptureContext(\n  hint,\n) {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return { captureContext: hint };\n  }\n\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint,\n    };\n  }\n\n  return hint;\n}\n\nfunction hintIsScopeOrFunction(hint) {\n  return hint instanceof Scope || typeof hint === 'function';\n}\n\nconst captureContextKeys = [\n  'user',\n  'level',\n  'extra',\n  'contexts',\n  'tags',\n  'fingerprint',\n  'propagationContext',\n] ;\n\nfunction hintIsScopeContext(hint) {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key ));\n}\n\nexport { applyClientOptions, applyDebugIds, applyDebugMeta, parseEventHintOrCaptureContext, prepareEvent };\n//# sourceMappingURL=prepareEvent.js.map\n"],"names":["prepareEvent","options","event","hint","scope","client","isolationScope","normalizeDepth","normalizeMaxBreadth","prepared","uuid4","dateTimestampInSeconds","integrations","i","applyClientOptions","applyIntegrationsMetadata","applyDebugIds","finalScope","getFinalScope","addExceptionMechanism","clientEventProcessors","data","getGlobalScope","isolationData","mergeScopeData","finalScopeData","attachments","applyScopeDataToEvent","eventProcessors","notifyEventProcessors","evt","applyDebugMeta","normalizeEvent","environment","release","dist","maxValueLength","DEFAULT_ENVIRONMENT","request","truncate","stackParser","filenameDebugIdMap","getFilenameToDebugIdMap","exception","frame","images","filename","debug_id","integrationNames","depth","maxBreadth","normalized","b","normalize","span","captureContext","Scope","parseEventHintOrCaptureContext"],"mappings":"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","x_google_ignoreList":[0]}