import{isThenable as u}from"./is.js";var h;(function(n){n[n.PENDING=0]="PENDING";const e=1;n[n.RESOLVED=e]="RESOLVED";const E=2;n[n.REJECTED=E]="REJECTED"})(h||(h={}));function D(n){return new c(t=>{t(n)})}function _(n){return new c((t,e)=>{e(n)})}class c{constructor(t){this._state=h.PENDING,this._handlers=[],this._runExecutor(t)}then(t,e){return new c((E,r)=>{this._handlers.push([!1,s=>{if(!t)E(s);else try{E(t(s))}catch(i){r(i)}},s=>{if(!e)r(s);else try{E(e(s))}catch(i){r(i)}}]),this._executeHandlers()})}catch(t){return this.then(e=>e,t)}finally(t){return new c((e,E)=>{let r,s;return this.then(i=>{s=!1,r=i,t&&t()},i=>{s=!0,r=i,t&&t()}).then(()=>{if(s){E(r);return}e(r)})})}_executeHandlers(){if(this._state===h.PENDING)return;const t=this._handlers.slice();this._handlers=[],t.forEach(e=>{e[0]||(this._state===h.RESOLVED&&e[1](this._value),this._state===h.REJECTED&&e[2](this._value),e[0]=!0)})}_runExecutor(t){const e=(s,i)=>{if(this._state===h.PENDING){if(u(i)){i.then(E,r);return}this._state=s,this._value=i,this._executeHandlers()}},E=s=>{e(h.RESOLVED,s)},r=s=>{e(h.REJECTED,s)};try{t(E,r)}catch(s){r(s)}}}export{c as SyncPromise,_ as rejectedSyncPromise,D as resolvedSyncPromise};
//# sourceMappingURL=syncpromise.js.map
