{"version":3,"file":"aggregate-errors.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/utils-hoist/aggregate-errors.js"],"sourcesContent":["import { isInstanceOf } from './is.js';\n\n/**\n * Creates exceptions inside `event.exception.values` for errors that are nested on properties based on the `key` parameter.\n */\nfunction applyAggregateErrorsToEvent(\n  exceptionFromErrorImplementation,\n  parser,\n  key,\n  limit,\n  event,\n  hint,\n) {\n  if (!event.exception?.values || !hint || !isInstanceOf(hint.originalException, Error)) {\n    return;\n  }\n\n  // Generally speaking the last item in `event.exception.values` is the exception originating from the original Error\n  const originalException =\n    event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : undefined;\n\n  // We only create exception grouping if there is an exception in the event.\n  if (originalException) {\n    event.exception.values = aggregateExceptionsFromError(\n      exceptionFromErrorImplementation,\n      parser,\n      limit,\n      hint.originalException ,\n      key,\n      event.exception.values,\n      originalException,\n      0,\n    );\n  }\n}\n\nfunction aggregateExceptionsFromError(\n  exceptionFromErrorImplementation,\n  parser,\n  limit,\n  error,\n  key,\n  prevExceptions,\n  exception,\n  exceptionId,\n) {\n  if (prevExceptions.length >= limit + 1) {\n    return prevExceptions;\n  }\n\n  let newExceptions = [...prevExceptions];\n\n  // Recursively call this function in order to walk down a chain of errors\n  if (isInstanceOf(error[key], Error)) {\n    applyExceptionGroupFieldsForParentException(exception, exceptionId);\n    const newException = exceptionFromErrorImplementation(parser, error[key]);\n    const newExceptionId = newExceptions.length;\n    applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);\n    newExceptions = aggregateExceptionsFromError(\n      exceptionFromErrorImplementation,\n      parser,\n      limit,\n      error[key],\n      key,\n      [newException, ...newExceptions],\n      newException,\n      newExceptionId,\n    );\n  }\n\n  // This will create exception grouping for AggregateErrors\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError\n  if (Array.isArray(error.errors)) {\n    error.errors.forEach((childError, i) => {\n      if (isInstanceOf(childError, Error)) {\n        applyExceptionGroupFieldsForParentException(exception, exceptionId);\n        const newException = exceptionFromErrorImplementation(parser, childError);\n        const newExceptionId = newExceptions.length;\n        applyExceptionGroupFieldsForChildException(newException, `errors[${i}]`, newExceptionId, exceptionId);\n        newExceptions = aggregateExceptionsFromError(\n          exceptionFromErrorImplementation,\n          parser,\n          limit,\n          childError,\n          key,\n          [newException, ...newExceptions],\n          newException,\n          newExceptionId,\n        );\n      }\n    });\n  }\n\n  return newExceptions;\n}\n\nfunction applyExceptionGroupFieldsForParentException(exception, exceptionId) {\n  // Don't know if this default makes sense. The protocol requires us to set these values so we pick *some* default.\n  exception.mechanism = exception.mechanism || { type: 'generic', handled: true };\n\n  exception.mechanism = {\n    ...exception.mechanism,\n    ...(exception.type === 'AggregateError' && { is_exception_group: true }),\n    exception_id: exceptionId,\n  };\n}\n\nfunction applyExceptionGroupFieldsForChildException(\n  exception,\n  source,\n  exceptionId,\n  parentId,\n) {\n  // Don't know if this default makes sense. The protocol requires us to set these values so we pick *some* default.\n  exception.mechanism = exception.mechanism || { type: 'generic', handled: true };\n\n  exception.mechanism = {\n    ...exception.mechanism,\n    type: 'chained',\n    source,\n    exception_id: exceptionId,\n    parent_id: parentId,\n  };\n}\n\nexport { applyAggregateErrorsToEvent };\n//# sourceMappingURL=aggregate-errors.js.map\n"],"names":["applyAggregateErrorsToEvent","exceptionFromErrorImplementation","parser","key","limit","event","hint","isInstanceOf","originalException","aggregateExceptionsFromError","error","prevExceptions","exception","exceptionId","newExceptions","applyExceptionGroupFieldsForParentException","newException","newExceptionId","applyExceptionGroupFieldsForChildException","childError","i","source","parentId"],"mappings":"uCAKA,SAASA,EACPC,EACAC,EACAC,EACAC,EACAC,EACAC,EACA,CACA,GAAI,CAACD,EAAM,WAAW,QAAU,CAACC,GAAQ,CAACC,EAAaD,EAAK,kBAAmB,KAAK,EAClF,OAIF,MAAME,EACJH,EAAM,UAAU,OAAO,OAAS,EAAIA,EAAM,UAAU,OAAOA,EAAM,UAAU,OAAO,OAAS,CAAC,EAAI,OAG9FG,IACFH,EAAM,UAAU,OAASI,EACvBR,EACAC,EACAE,EACAE,EAAK,kBACLH,EACAE,EAAM,UAAU,OAChBG,EACA,CACD,EAEL,CAEA,SAASC,EACPR,EACAC,EACAE,EACAM,EACAP,EACAQ,EACAC,EACAC,EACA,CACA,GAAIF,EAAe,QAAUP,EAAQ,EACnC,OAAOO,EAGT,IAAIG,EAAgB,CAAC,GAAGH,CAAc,EAGtC,GAAIJ,EAAaG,EAAMP,CAAG,EAAG,KAAK,EAAG,CACnCY,EAA4CH,EAAWC,CAAW,EAClE,MAAMG,EAAef,EAAiCC,EAAQQ,EAAMP,CAAG,CAAC,EAClEc,EAAiBH,EAAc,OACrCI,EAA2CF,EAAcb,EAAKc,EAAgBJ,CAAW,EACzFC,EAAgBL,EACdR,EACAC,EACAE,EACAM,EAAMP,CAAG,EACTA,EACA,CAACa,EAAc,GAAGF,CAAa,EAC/BE,EACAC,CACD,CACL,CAIE,OAAI,MAAM,QAAQP,EAAM,MAAM,GAC5BA,EAAM,OAAO,QAAQ,CAACS,EAAYC,IAAM,CACtC,GAAIb,EAAaY,EAAY,KAAK,EAAG,CACnCJ,EAA4CH,EAAWC,CAAW,EAClE,MAAMG,EAAef,EAAiCC,EAAQiB,CAAU,EAClEF,EAAiBH,EAAc,OACrCI,EAA2CF,EAAc,UAAUI,CAAC,IAAKH,EAAgBJ,CAAW,EACpGC,EAAgBL,EACdR,EACAC,EACAE,EACAe,EACAhB,EACA,CAACa,EAAc,GAAGF,CAAa,EAC/BE,EACAC,CACD,CACT,CACA,CAAK,EAGIH,CACT,CAEA,SAASC,EAA4CH,EAAWC,EAAa,CAE3ED,EAAU,UAAYA,EAAU,WAAa,CAAE,KAAM,UAAW,QAAS,EAAM,EAE/EA,EAAU,UAAY,CACpB,GAAGA,EAAU,UACb,GAAIA,EAAU,OAAS,kBAAoB,CAAE,mBAAoB,EAAI,EACrE,aAAcC,CACf,CACH,CAEA,SAASK,EACPN,EACAS,EACAR,EACAS,EACA,CAEAV,EAAU,UAAYA,EAAU,WAAa,CAAE,KAAM,UAAW,QAAS,EAAM,EAE/EA,EAAU,UAAY,CACpB,GAAGA,EAAU,UACb,KAAM,UACN,OAAAS,EACA,aAAcR,EACd,UAAWS,CACZ,CACH","x_google_ignoreList":[0]}