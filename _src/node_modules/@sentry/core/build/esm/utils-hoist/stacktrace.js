const R="?",m=/\(error: (.*)\)/,E=/captureMessage|captureException/;function F(...t){const e=t.sort((n,r)=>n[0]-r[0]).map(n=>n[1]);return(n,r=0,u=0)=>{const s=[],f=n.split(`
`);for(let i=r;i<f.length;i++){const c=f[i];if(c.length>1024)continue;const p=m.test(c)?c.replace(m,"$1"):c;if(!p.match(/\S*Error: /)){for(const A of e){const l=A(p);if(l){s.push(l);break}}if(s.length>=50+u)break}}return _(s.slice(u))}}function h(t){return Array.isArray(t)?F(...t):t}function _(t){if(!t.length)return[];const e=Array.from(t);return/sentryWrapped/.test(o(e).function||"")&&e.pop(),e.reverse(),E.test(o(e).function||"")&&(e.pop(),E.test(o(e).function||"")&&e.pop()),e.slice(0,50).map(n=>({...n,filename:n.filename||o(e).filename,function:n.function||R}))}function o(t){return t[t.length-1]||{}}const a="<anonymous>";function S(t){try{return!t||typeof t!="function"?a:t.name||a}catch{return a}}function T(t){const e=t.exception;if(e){const n=[];try{return e.values.forEach(r=>{r.stacktrace.frames&&n.push(...r.stacktrace.frames)}),n}catch{return}}}export{R as UNKNOWN_FUNCTION,F as createStackParser,T as getFramesFromEvent,S as getFunctionName,h as stackParserFromStackParserOptions,_ as stripSentryFramesAndReverse};
//# sourceMappingURL=stacktrace.js.map
