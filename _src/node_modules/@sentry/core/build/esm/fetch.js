import{getClient as h}from"./currentScopes.js";import{SEMANTIC_ATTRIBUTE_SENTRY_OP as T,SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN as y}from"./semanticAttributes.js";import{isRequest as b,isInstanceOf as H}from"./utils-hoist/is.js";import{hasSpansEnabled as S}from"./utils/hasSpansEnabled.js";import{getActiveSpan as R}from"./utils/spanUtils.js";import{SENTRY_BAGGAGE_KEY_PREFIX as _}from"./utils-hoist/baggage.js";import{SentryNonRecordingSpan as A}from"./tracing/sentryNonRecordingSpan.js";import{setHttpStatus as I,SPAN_STATUS_ERROR as E}from"./tracing/spanstatus.js";import{startInactiveSpan as B}from"./tracing/trace.js";import{getTraceData as N}from"./utils/traceData.js";import{parseStringToURLObject as O,getSanitizedUrlStringFromUrlObject as v,isURLObjectRelative as w}from"./utils-hoist/url.js";function U(e,t,g,s,a="auto.http.browser"){if(!e.fetchData)return;const{method:c,url:r}=e.fetchData,i=S()&&t(r);if(e.endTimestamp&&i){const f=e.fetchData.__span;if(!f)return;const u=s[f];u&&(q(u,e),delete s[f]);return}const n=!!R(),o=i&&n?B(F(r,c,a)):new A;if(e.fetchData.__span=o.spanContext().spanId,s[o.spanContext().spanId]=o,g(e.fetchData.url)){const f=e.args[0],u=e.args[1]||{},d=C(f,u,S()&&n?o:void 0);d&&(e.args[1]=u,u.headers=d)}const p=h();if(p){const f={input:e.args,response:e.response,startTimestamp:e.startTimestamp,endTimestamp:e.endTimestamp};p.emit("beforeOutgoingRequestSpan",o,f)}return o}function C(e,t,g){const s=N({span:g}),a=s["sentry-trace"],c=s.baggage;if(!a)return;const r=t.headers||(b(e)?e.headers:void 0);if(r)if(x(r)){const i=new Headers(r);if(i.get("sentry-trace")||i.set("sentry-trace",a),c){const n=i.get("baggage");n?m(n)||i.set("baggage",`${n},${c}`):i.set("baggage",c)}return i}else if(Array.isArray(r)){const i=[...r];r.find(o=>o[0]==="sentry-trace")||i.push(["sentry-trace",a]);const n=r.find(o=>o[0]==="baggage"&&m(o[1]));return c&&!n&&i.push(["baggage",c]),i}else{const i="sentry-trace"in r?r["sentry-trace"]:void 0,n="baggage"in r?r.baggage:void 0,o=n?Array.isArray(n)?[...n]:[n]:[],p=n&&(Array.isArray(n)?n.find(f=>m(f)):m(n));return c&&!p&&o.push(c),{...r,"sentry-trace":i??a,baggage:o.length>0?o.join(","):void 0}}else return{...s}}function q(e,t){if(t.response){I(e,t.response.status);const g=t.response?.headers&&t.response.headers.get("content-length");if(g){const s=parseInt(g);s>0&&e.setAttribute("http.response_content_length",s)}}else t.error&&e.setStatus({code:E,message:"internal_error"});e.end()}function m(e){return e.split(",").some(t=>t.trim().startsWith(_))}function x(e){return typeof Headers<"u"&&H(e,Headers)}function F(e,t,g){const s=O(e);return{name:s?`${t} ${v(s)}`:t,attributes:j(e,s,t,g)}}function j(e,t,g,s){const a={url:e,type:"fetch","http.method":g,[y]:s,[T]:"http.client"};return t&&(w(t)||(a["http.url"]=t.href,a["server.address"]=t.host),t.search&&(a["http.query"]=t.search),t.hash&&(a["http.fragment"]=t.hash)),a}export{C as _addTracingHeadersToFetchRequest,U as instrumentFetchRequest};
//# sourceMappingURL=fetch.js.map
