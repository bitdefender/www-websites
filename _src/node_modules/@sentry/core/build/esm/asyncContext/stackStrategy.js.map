{"version":3,"file":"stackStrategy.js","sources":["../../../../../../../node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js"],"sourcesContent":["import { getDefaultCurrentScope, getDefaultIsolationScope } from '../defaultScopes.js';\nimport { Scope } from '../scope.js';\nimport { isThenable } from '../utils-hoist/is.js';\nimport { getMainCarrier, getSentryCarrier } from '../carrier.js';\n\n/**\n * This is an object that holds a stack of scopes.\n */\nclass AsyncContextStack {\n\n   constructor(scope, isolationScope) {\n    let assignedScope;\n    if (!scope) {\n      assignedScope = new Scope();\n    } else {\n      assignedScope = scope;\n    }\n\n    let assignedIsolationScope;\n    if (!isolationScope) {\n      assignedIsolationScope = new Scope();\n    } else {\n      assignedIsolationScope = isolationScope;\n    }\n\n    // scope stack for domains or the process\n    this._stack = [{ scope: assignedScope }];\n    this._isolationScope = assignedIsolationScope;\n  }\n\n  /**\n   * Fork a scope for the stack.\n   */\n   withScope(callback) {\n    const scope = this._pushScope();\n\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback(scope);\n    } catch (e) {\n      this._popScope();\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      // @ts-expect-error - isThenable returns the wrong type\n      return maybePromiseResult.then(\n        res => {\n          this._popScope();\n          return res;\n        },\n        e => {\n          this._popScope();\n          throw e;\n        },\n      );\n    }\n\n    this._popScope();\n    return maybePromiseResult;\n  }\n\n  /**\n   * Get the client of the stack.\n   */\n   getClient() {\n    return this.getStackTop().client ;\n  }\n\n  /**\n   * Returns the scope of the top stack.\n   */\n   getScope() {\n    return this.getStackTop().scope;\n  }\n\n  /**\n   * Get the isolation scope for the stack.\n   */\n   getIsolationScope() {\n    return this._isolationScope;\n  }\n\n  /**\n   * Returns the topmost scope layer in the order domain > local > process.\n   */\n   getStackTop() {\n    return this._stack[this._stack.length - 1] ;\n  }\n\n  /**\n   * Push a scope to the stack.\n   */\n   _pushScope() {\n    // We want to clone the content of prev scope\n    const scope = this.getScope().clone();\n    this._stack.push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * Pop a scope from the stack.\n   */\n   _popScope() {\n    if (this._stack.length <= 1) return false;\n    return !!this._stack.pop();\n  }\n}\n\n/**\n * Get the global async context stack.\n * This will be removed during the v8 cycle and is only here to make migration easier.\n */\nfunction getAsyncContextStack() {\n  const registry = getMainCarrier();\n  const sentry = getSentryCarrier(registry);\n\n  return (sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope()));\n}\n\nfunction withScope(callback) {\n  return getAsyncContextStack().withScope(callback);\n}\n\nfunction withSetScope(scope, callback) {\n  const stack = getAsyncContextStack() ;\n  return stack.withScope(() => {\n    stack.getStackTop().scope = scope;\n    return callback(scope);\n  });\n}\n\nfunction withIsolationScope(callback) {\n  return getAsyncContextStack().withScope(() => {\n    return callback(getAsyncContextStack().getIsolationScope());\n  });\n}\n\n/**\n * Get the stack-based async context strategy.\n */\nfunction getStackAsyncContextStrategy() {\n  return {\n    withIsolationScope,\n    withScope,\n    withSetScope,\n    withSetIsolationScope: (_isolationScope, callback) => {\n      return withIsolationScope(callback);\n    },\n    getCurrentScope: () => getAsyncContextStack().getScope(),\n    getIsolationScope: () => getAsyncContextStack().getIsolationScope(),\n  };\n}\n\nexport { AsyncContextStack, getStackAsyncContextStrategy };\n//# sourceMappingURL=stackStrategy.js.map\n"],"names":["AsyncContextStack","scope","isolationScope","assignedScope","Scope","assignedIsolationScope","callback","maybePromiseResult","e","isThenable","res","getAsyncContextStack","registry","getMainCarrier","sentry","getSentryCarrier","getDefaultCurrentScope","getDefaultIsolationScope","withScope","withSetScope","stack","withIsolationScope","getStackAsyncContextStrategy","_isolationScope"],"mappings":"sPAQA,MAAMA,CAAkB,CAErB,YAAYC,EAAOC,EAAgB,CAClC,IAAIC,EACCF,EAGHE,EAAgBF,EAFhBE,EAAgB,IAAIC,EAKtB,IAAIC,EACCH,EAGHG,EAAyBH,EAFzBG,EAAyB,IAAID,EAM/B,KAAK,OAAS,CAAC,CAAE,MAAOD,CAAa,CAAE,EACvC,KAAK,gBAAkBE,CAC3B,CAKG,UAAUC,EAAU,CACnB,MAAML,EAAQ,KAAK,WAAY,EAE/B,IAAIM,EACJ,GAAI,CACFA,EAAqBD,EAASL,CAAK,CACpC,OAAQO,EAAG,CACV,WAAK,UAAW,EACVA,CACZ,CAEI,OAAIC,EAAWF,CAAkB,EAExBA,EAAmB,KACxBG,IACE,KAAK,UAAW,EACTA,GAETF,GAAK,CACH,WAAK,UAAW,EACVA,CACP,CACF,GAGH,KAAK,UAAW,EACTD,EACX,CAKG,WAAY,CACX,OAAO,KAAK,YAAW,EAAG,MAC9B,CAKG,UAAW,CACV,OAAO,KAAK,YAAW,EAAG,KAC9B,CAKG,mBAAoB,CACnB,OAAO,KAAK,eAChB,CAKG,aAAc,CACb,OAAO,KAAK,OAAO,KAAK,OAAO,OAAS,CAAC,CAC7C,CAKG,YAAa,CAEZ,MAAMN,EAAQ,KAAK,SAAQ,EAAG,MAAO,EACrC,YAAK,OAAO,KAAK,CACf,OAAQ,KAAK,UAAW,EACxB,MAAAA,CACN,CAAK,EACMA,CACX,CAKG,WAAY,CACX,OAAI,KAAK,OAAO,QAAU,EAAU,GAC7B,CAAC,CAAC,KAAK,OAAO,IAAK,CAC9B,CACA,CAMA,SAASU,GAAuB,CAC9B,MAAMC,EAAWC,EAAgB,EAC3BC,EAASC,EAAiBH,CAAQ,EAExC,OAAQE,EAAO,MAAQA,EAAO,OAAS,IAAId,EAAkBgB,IAA0BC,GAA0B,CACnH,CAEA,SAASC,EAAUZ,EAAU,CAC3B,OAAOK,EAAoB,EAAG,UAAUL,CAAQ,CAClD,CAEA,SAASa,EAAalB,EAAOK,EAAU,CACrC,MAAMc,EAAQT,EAAsB,EACpC,OAAOS,EAAM,UAAU,KACrBA,EAAM,cAAc,MAAQnB,EACrBK,EAASL,CAAK,EACtB,CACH,CAEA,SAASoB,EAAmBf,EAAU,CACpC,OAAOK,EAAoB,EAAG,UAAU,IAC/BL,EAASK,IAAuB,mBAAmB,CAC3D,CACH,CAKA,SAASW,GAA+B,CACtC,MAAO,CACL,mBAAAD,EACA,UAAAH,EACA,aAAAC,EACA,sBAAuB,CAACI,EAAiBjB,IAChCe,EAAmBf,CAAQ,EAEpC,gBAAiB,IAAMK,EAAsB,EAAC,SAAU,EACxD,kBAAmB,IAAMA,EAAsB,EAAC,kBAAmB,CACpE,CACH","x_google_ignoreList":[0]}